<html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head>
	<meta charset="utf-8">
	<title>ther_new</title>
	<style type="text/css">
:root { --html-font-name: ui-monospace; --code-font-name: ui-monospace; --html-font-size: 18px; --html-header-alignment: left; --html-text-align: justify; }
html { text-rendering: optimizeLegibility !important; }
h1, h2, h3 { -webkit-hyphens: none !important; }
img, pre, blockquote, table, figure { page-break-inside: avoid; }

body
{
    font-family: var(--html-font-name), Helvetica Neue, Georgia, serif;
    font-size: var(--html-font-size) !important;
    line-height: 1.4em !important;
    text-align: var(--html-text-align);
    background-color: white !important;
    color: black !important;
    padding: 2em !important;
    width: 90% !important;
}

h1, h2, h3, h4, h5, h6
{
    page-break-after: avoid !important;
    page-break-inside: avoid !important;
    text-align: var(--html-header-alignment);
}

h1::after {
    content: "";
    display: block;
    height: 100px;
    margin-bottom: -100px;
}

hr
{
    color:#E0E0E0;
    background-color:#E0E0E0;
    border-color: #E0E0E0;
}

pre, code
{
    font-family: var(--code-font-name), ui-monospace, "Lucida Console", "Consolas", "Menlo", "Monaco", "Courier", monospace;
    color: inherit;
    background: #FAFAFA !important;
    line-height: 1.4em;
}

blockquote
{
    margin-left: none;
    margin-right: auto;
    width: 96%;
    padding-left: 0.3em;
    border-left: 3px solid darkgrey;
    color: darkgrey;
}

table
{
    margin-left: auto;
    margin-right: auto;
    margin-bottom: 1em;
    border-bottom: 1px solid #dddddd;
    border-right: 1px solid #dddddd;
    border-spacing: 0;
    background-color:transparent;
}

table th
{
    padding: 3px 10px;
    border-top: 1px solid;
    border-left: 1px solid;
    
    background-color: #eeeeee;
    border-color: #dddddd;
}

table td
{
    padding: 3px 10px;
    border-top: 1px solid;
    border-left: 1px solid;
    border-color: #dddddd;
}

mark
{
    background-color: yellow;
}

li.selected
{
    color: #cccccc;
    text-decoration: line-through;
    list-style-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPScxMycgaGVpZ2h0PScxMyc+IDxyZWN0IHN0cm9rZT0nI2NjY2NjYycgc3Ryb2tlLXdpZHRoPScwLjUnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgZmlsbD0nI0ZGRkZGRicgeD0nMC4yNScgeT0nMC4yNScgd2lkdGg9JzEyLjUnIGhlaWdodD0nMTIuNScgcng9JzInIC8+PGcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoNywgNikgcm90YXRlKDQ1KScgZmlsbD0nIzEzOWFmZicgc3Ryb2tlPSdub25lJz48cmVjdCB4PSctMycgeT0nMicgd2lkdGg9JzUnIGhlaWdodD0nMicgcng9JzEnIC8+PHJlY3QgeD0nMCcgeT0nLTMuNScgd2lkdGg9JzInIGhlaWdodD0nNycgcng9JzEnIC8+PC9nPjwvc3ZnPg==");
}

li.unselected
{
    list-style-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPScxMycgaGVpZ2h0PScxMyc+IDxyZWN0IHN0cm9rZT0nI2NjY2NjYycgc3Ryb2tlLXdpZHRoPScwLjUnIHN0cm9rZS1taXRlcmxpbWl0PScxMCcgZmlsbD0nI0ZGRkZGRicgeD0nMC4yNScgeT0nMC4yNScgd2lkdGg9JzEyLjUnIGhlaWdodD0nMTIuNScgcng9JzInIC8+PC9zdmc+");
}

/* Common CSS. No colors here, just layout. */

html
{
    /* scroll-behavior: smooth;*/
    -webkit-font-smoothing: antialiased;
}

body
{
	width: 99.9%;
	padding: 0;
	border: 0;
	line-height: 1.8em;
	word-wrap: break-word;
}

#content
{
	margin: 0 auto;
}

/* Disable margin for the very first element in the tree. */
#content > *
{
    margin-top: 0;
}

h1, h2, h3, h4, h5, h6
{
    text-rendering: optimizeLegibility;
    margin: 1.5em 0 0.5em 0;
}

h1
{
    font-size:1.5em;
}

h2
{
    font-size:1.3em;
}

h3
{
    font-size:1.2em;
}

h4, h5, h6
{
    font-size:1.0em;
}

p
{
	margin:1em 0 1em 0;
}

p:last-child
{
	margin:0;
}

hr
{
	width: 100%;
	margin: 3em auto;
	border: 0;
	height: 1px;
}

/* List elements */

ol
{
    list-style: inside decimal;
}

ul
{
    list-style: inside disc;
}

li > ul
{
  list-style: inside circle;
}

li > ul > li > ul
{
  list-style: inside square;
}

ol, ul
{
    padding-left:0;
    margin-bottom:1em;
}

ol li, ul li
{
    margin-left:0;
    text-align: -webkit-match-parent;
}

ol:last-child, ul:last-child
{
    margin:0;
}

li > p
{
    margin-bottom:0.5em;
}

li > ol, li > ul
{
    margin-top: 0.5em !important;
    padding-left:2em;
}

/* Description list elements */

dl
{
	margin-bottom:1em;
}

dl dt
{
	font-weight:bold;
	margin-bottom:0.3em;
}

dl dd
{
	margin-left:0;
	margin-bottom:0.5em;
}

dl dd:last-child, dl:last-child
{
	margin-bottom:0;
}

/* Block code */

pre, code
{
    white-space: pre;
}

pre
{
	width: 96%;
    border: 0px;
    overflow: auto;
    margin-bottom: 2em;
    line-height: 1.4em;
    -webkit-border-radius: 3pt;
    -moz-border-radius: 3pt;
    padding: 1em 1.5em;
    tab-size: 4;
    text-align: start;
}

pre > code
{
    padding: 0;
}

code
{
    font-size: 85%;
    padding: 2pt 3pt;
    -webkit-border-radius: 2pt;
    -moz-border-radius: 2pt;
}

/* MD Plugins */

.flowchart, .flow
{
    display: flex;
    align-items: center;
    justify-content: center;
    background: transparent !important;
}

.mermaid
{
    background: transparent !important;
}

.pieTitleText {
  font-size: 1.2em !important;
}

/* Block quotes */

blockquote
{
	margin-left: 0;
	margin-right: auto;
	width: 96%;
	padding: 0 0.5em;
	border-left: 3px solid;
}

blockquote > *
{
    text-align: inherit;
}

/* Tables */

table
{
	margin-left: auto;
	margin-right: auto;
	margin-bottom: 1em;
	border-bottom: 1px solid;
	border-right: 1px solid;
	border-spacing: 0;
}

table th
{
	padding: 3px 10px;
	border-top: 1px solid;
	border-left: 1px solid;
}

table td
{
	padding: 3px 10px;
	border-top: 1px solid;
	border-left: 1px solid;
}

caption
{
    font-size: 1.0em;
    text-decoration: italic;
    margin-bottom: 5px;
}

/* Images */

figure
{
	display: block;
	text-align: center;
    margin: auto;
}

img
{
	border: none;
	margin: 1em auto;
	max-width: 100%;
}

figcaption
{
	font-size: 1.0em;
	font-style: italic;
}

mark
{
	padding:1px 3px;
}
pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}.hljs{background:#fff;color:#000}.xml .hljs-meta{color:silver}.hljs-comment,.hljs-quote{color:#007400}.hljs-attribute,.hljs-keyword,.hljs-literal,.hljs-name,.hljs-selector-tag,.hljs-tag{color:#aa0d91}.hljs-template-variable,.hljs-variable{color:#3f6e74}.hljs-code,.hljs-meta .hljs-string,.hljs-string{color:#c41a16}.hljs-link,.hljs-regexp{color:#0e0eff}.hljs-bullet,.hljs-number,.hljs-symbol,.hljs-title{color:#1c00cf}.hljs-meta,.hljs-section{color:#643820}.hljs-built_in,.hljs-class .hljs-title,.hljs-params,.hljs-title.class_,.hljs-type{color:#5c2699}.hljs-attr{color:#836c28}.hljs-subst{color:#000}.hljs-formula{background-color:#eee;font-style:italic}.hljs-addition{background-color:#baeeba}.hljs-deletion{background-color:#ffc8bd}.hljs-selector-class,.hljs-selector-id{color:#9b703f}.hljs-doctag,.hljs-strong{font-weight:700}.hljs-emphasis{font-style:italic}

	</style>










<style type="text/css">.CtxtMenu_InfoClose {  top:.2em; right:.2em;}
.CtxtMenu_InfoContent {  overflow:auto; text-align:left; font-size:80%;  padding:.4em .6em; border:1px inset; margin:1em 0px;  max-height:20em; max-width:30em; background-color:#EEEEEE;  white-space:normal;}
.CtxtMenu_Info.CtxtMenu_MousePost {outline:none;}
.CtxtMenu_Info {  position:fixed; left:50%; width:auto; text-align:center;  border:3px outset; padding:1em 2em; background-color:#DDDDDD;  color:black;  cursor:default; font-family:message-box; font-size:120%;  font-style:normal; text-indent:0; text-transform:none;  line-height:normal; letter-spacing:normal; word-spacing:normal;  word-wrap:normal; white-space:nowrap; float:none; z-index:201;  border-radius: 15px;                     /* Opera 10.5 and IE9 */  -webkit-border-radius:15px;               /* Safari and Chrome */  -moz-border-radius:15px;                  /* Firefox */  -khtml-border-radius:15px;                /* Konqueror */  box-shadow:0px 10px 20px #808080;         /* Opera 10.5 and IE9 */  -webkit-box-shadow:0px 10px 20px #808080; /* Safari 3 & Chrome */  -moz-box-shadow:0px 10px 20px #808080;    /* Forefox 3.5 */  -khtml-box-shadow:0px 10px 20px #808080;  /* Konqueror */  filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color="gray", Positive="true"); /* IE */}
</style><style type="text/css">.CtxtMenu_MenuClose {  position:absolute;  cursor:pointer;  display:inline-block;  border:2px solid #AAA;  border-radius:18px;  -webkit-border-radius: 18px;             /* Safari and Chrome */  -moz-border-radius: 18px;                /* Firefox */  -khtml-border-radius: 18px;              /* Konqueror */  font-family: "Courier New", Courier;  font-size:24px;  color:#F0F0F0}
.CtxtMenu_MenuClose span {  display:block; background-color:#AAA; border:1.5px solid;  border-radius:18px;  -webkit-border-radius: 18px;             /* Safari and Chrome */  -moz-border-radius: 18px;                /* Firefox */  -khtml-border-radius: 18px;              /* Konqueror */  line-height:0;  padding:8px 0 6px     /* may need to be browser-specific */}
.CtxtMenu_MenuClose:hover {  color:white!important;  border:2px solid #CCC!important}
.CtxtMenu_MenuClose:hover span {  background-color:#CCC!important}
.CtxtMenu_MenuClose:hover:focus {  outline:none}
</style><style type="text/css">.CtxtMenu_Menu {  position:absolute;  background-color:white;  color:black;  width:auto; padding:5px 0px;  border:1px solid #CCCCCC; margin:0; cursor:default;  font: menu; text-align:left; text-indent:0; text-transform:none;  line-height:normal; letter-spacing:normal; word-spacing:normal;  word-wrap:normal; white-space:nowrap; float:none; z-index:201;  border-radius: 5px;                     /* Opera 10.5 and IE9 */  -webkit-border-radius: 5px;             /* Safari and Chrome */  -moz-border-radius: 5px;                /* Firefox */  -khtml-border-radius: 5px;              /* Konqueror */  box-shadow:0px 10px 20px #808080;         /* Opera 10.5 and IE9 */  -webkit-box-shadow:0px 10px 20px #808080; /* Safari 3 & Chrome */  -moz-box-shadow:0px 10px 20px #808080;    /* Forefox 3.5 */  -khtml-box-shadow:0px 10px 20px #808080;  /* Konqueror */}
.CtxtMenu_MenuItem {  padding: 1px 2em;  background:transparent;}
.CtxtMenu_MenuArrow {  position:absolute; right:.5em; padding-top:.25em; color:#666666;  font-family: null; font-size: .75em}
.CtxtMenu_MenuActive .CtxtMenu_MenuArrow {color:white}
.CtxtMenu_MenuArrow.CtxtMenu_RTL {left:.5em; right:auto}
.CtxtMenu_MenuCheck {  position:absolute; left:.7em;  font-family: null}
.CtxtMenu_MenuCheck.CtxtMenu_RTL { right:.7em; left:auto }
.CtxtMenu_MenuRadioCheck {  position:absolute; left: .7em;}
.CtxtMenu_MenuRadioCheck.CtxtMenu_RTL {  right: .7em; left:auto}
.CtxtMenu_MenuInputBox {  padding-left: 1em; right:.5em; color:#666666;  font-family: null;}
.CtxtMenu_MenuInputBox.CtxtMenu_RTL {  left: .1em;}
.CtxtMenu_MenuComboBox {  left:.1em; padding-bottom:.5em;}
.CtxtMenu_MenuSlider {  left: .1em;}
.CtxtMenu_SliderValue {  position:absolute; right:.1em; padding-top:.25em; color:#333333;  font-size: .75em}
.CtxtMenu_SliderBar {  outline: none; background: #d3d3d3}
.CtxtMenu_MenuLabel {  padding: 1px 2em 3px 1.33em;  font-style:italic}
.CtxtMenu_MenuRule {  border-top: 1px solid #DDDDDD;  margin: 4px 3px;}
.CtxtMenu_MenuDisabled {  color:GrayText}
.CtxtMenu_MenuActive {  background-color: #606872;  color: white;}
.CtxtMenu_MenuDisabled:focus {  background-color: #E8E8E8}
.CtxtMenu_MenuLabel:focus {  background-color: #E8E8E8}
.CtxtMenu_ContextMenu:focus {  outline:none}
.CtxtMenu_ContextMenu .CtxtMenu_MenuItem:focus {  outline:none}
.CtxtMenu_SelectionMenu {  position:relative; float:left;  border-bottom: none; -webkit-box-shadow:none; -webkit-border-radius:0px; }
.CtxtMenu_SelectionItem {  padding-right: 1em;}
.CtxtMenu_Selection {  right: 40%; width:50%; }
.CtxtMenu_SelectionBox {  padding: 0em; max-height:20em; max-width: none;  background-color:#FFFFFF;}
.CtxtMenu_SelectionDivider {  clear: both; border-top: 2px solid #000000;}
.CtxtMenu_Menu .CtxtMenu_MenuClose {  top:-10px; left:-10px}
</style><style id="MJX-SVG-styles">
mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
  min-height: 1px;
  min-width: 1px;
}

mjx-container[jax="SVG"] > svg a {
  fill: blue;
  stroke: blue;
}

mjx-assistive-mml {
  position: absolute !important;
  top: 0px;
  left: 0px;
  clip: rect(1px, 1px, 1px, 1px);
  padding: 1px 0px 0px 0px !important;
  border: 0px !important;
  display: block !important;
  width: auto !important;
  overflow: hidden !important;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

mjx-assistive-mml[display="block"] {
  width: 100% !important;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][display="true"][width="full"] {
  display: flex;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line], svg[data-table] > g > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame], svg[data-table] > g > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed, svg[data-table] > g > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted, svg[data-table] > g > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > g > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

mjx-container[jax="SVG"] path[data-c], mjx-container[jax="SVG"] use[data-c] {
  stroke-width: 3;
}
</style></head>
<body>

<div class="TOC">

<ul>
<li><a href="#Указательнаvoid.Стандартныефункцииобработкиобластейпамяти.🔼top"><strong>Указатель на void. Стандартные функции обработки областей памяти.</strong> </a><a href="#top">🔼</a>
<ul>
<li><a href="#Указательнаvoid.🔼top"><strong>Указатель на void.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#Стандартныефункцииобработкиобластейпамяти.🔼top"><strong>Стандартные функции обработки областей памяти.</strong> </a><a href="#top">🔼</a></li>
</ul>
</li>
<li><a href="#Функциидинамическоговыделенияпамяти.🔼top"><strong>Функции динамического выделения памяти.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#Выделенияпамятиподдинамическиймассив.Типичныеошибкиприработесдинамическойпамятью.🔼top"><strong>Выделения памяти под динамический массив. Типичные ошибки при работе с динамической памятью.</strong></a><a href="#top">🔼</a></li>
<li><a href="#Указателинафункции.Функцияqsort.🔼top"><strong>Указатели на функции. Функция <code>qsort</code>.</strong></a><a href="#top">🔼</a></li>
<li><a href="#Утилитаmake.Назначение.Простойсценарийсборки.🔼top"><strong>Утилита Make. Назначение. Простой сценарий сборки.</strong></a><a href="#top">🔼</a>
<ul>
<li><a href="#Утилитаmake.Назначение.🔼top"><strong>Утилита Make. Назначение.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#Простойсценарийсборки.🔼top"><strong>Простой сценарий сборки.</strong> </a><a href="#top">🔼</a></li>
</ul>
</li>
<li><a href="#Утилитаmake.Назначение.Переменныешаблонныеправила.🔼top"><strong>Утилита <code>Make</code>. Назначение. Переменные, шаблонные правила.</strong></a><a href="#top">🔼</a>
<ul>
<li><a href="#Утилитаmake.Назначение.🔼top"><strong>Утилита <code>Make</code>. Назначение.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#Переменныешаблонныеправила.🔼top"><strong>Переменные, шаблонные правила.</strong> </a><a href="#top">🔼</a></li>
</ul>
</li>
<li><a href="#Утилитаmake.Назначение.Условныеконструкцииианализзависимостей.🔼top"><strong>Утилита <code>Make</code>. Назначение. Условные конструкции и анализ зависимостей.</strong> </a><a href="#top">🔼</a>
<ul>
<li><a href="#Утилитаmake.Назначение.🔼top"><strong>Утилита <code>Make</code>. Назначение.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#Условныеконструкцииианализзависимостей.🔼top"><strong>Условные конструкции и анализ зависимостей.</strong> </a><a href="#top">🔼</a></li>
</ul>
</li>
<li><a href="#Динамическиематрицы.Представлениеввидеодномерногомассиваиввидемассивауказателейнастроки.Анализпреимуществинедостатков.🔼top"><strong>Динамические матрицы. Представление в виде одномерного массива и в виде массива указателей на строки. Анализ преимуществ и недостатков.</strong> </a><a href="#top">🔼</a>
<ul>
<li><a href="#Матрицакакодномерныймассив.🔼top"><strong>Матрица как одномерный массив.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#Матрицакакмассивуказателей.🔼top"><strong>Матрица как массив указателей.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#Объединениеподходов1.🔼top"><strong>Объединение подходов (1).</strong> </a><a href="#top">🔼</a></li>
<li><a href="#Объединениеподходов2.🔼top"><strong>Объединение подходов (2).</strong> </a><a href="#top">🔼</a></li>
</ul>
</li>
<li><a href="#Чтениесложныхобъявлений.🔼top"><strong>Чтение сложных объявлений.</strong></a><a href="#top">🔼</a></li>
<li><a href="#Строкивдинамическойпамяти.Функцииposixирасширениеgnustrdupgetlinesprintf.🔼top"><strong>Строки в динамической памяти. Функции POSIX и расширение GNU (<code>strdup</code>, <code>getline</code>, <code>sprintf</code>).</strong></a><a href="#top">🔼</a></li>
<li><a href="#Использованиеструктурсполями-указателями.🔼top"><strong>Использование структур с полями-указателями.</strong></a><a href="#top">🔼</a></li>
<li><a href="#Структурыпеременногоразмера.🔼top"><strong>Структуры переменного размера.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#Динамическирасширяемыймассив.🔼top"><strong>Динамически расширяемый массив.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#Линейныйодносвязныйсписок.🔼top"><strong>Линейный односвязный список.</strong> </a><a href="#top">🔼</a>
<ul>
<li><a href="#Добавлениевначало.🔼top"><strong>Добавление в начало.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#Добавлениевконец.🔼top"><strong>Добавление в конец.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#Удалениесписка.🔼top"><strong>Удаление списка.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#Освобождениесписка.🔼top"><strong>Освобождение списка.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#Вставкапередузлом.🔼top"><strong>Вставка перед узлом.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#Вставкапослеузла.🔼top"><strong>Вставка после узла.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#Универсальныйобход.🔼top"><strong>Универсальный обход.</strong> </a><a href="#top">🔼</a></li>
</ul>
</li>
<li><a href="#Двоичноедеревопоиска.🔼top"><strong>Двоичное дерево поиска.</strong> </a><a href="#top">🔼</a>
<ul>
<li><a href="#Узелдерева.🔼top"><strong>Узел дерева.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#Сравнениесдеревом.🔼top"><strong>Сравнение с деревом.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#Рекурсивныйпоиск.🔼top"><strong>Рекурсивный поиск.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#Итеративныйпоиск.🔼top"><strong>Итеративный поиск.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#Добавлениеузла.🔼top"><strong>Добавление узла.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#Универсальныйобход.🔼top"><strong>Универсальный обход.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#Рекурсивноеудаление.🔼top"><strong>Рекурсивное удаление.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#Итеративноеудаление.🔼top"><strong>Итеративное удаление.</strong> </a><a href="#top">🔼</a></li>
</ul>
</li>
<li><a href="#КучавСи.Алгоритмыработыmallocfree.Выравнивание.🔼top"><strong>Куча в Си. Алгоритмы работы <code>malloc</code>, <code>free</code>. Выравнивание.</strong> </a><a href="#top">🔼</a>
<ul>
<li><a href="#КучавСи.🔼top"><strong>Куча в Си.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#Алгоритмыработыmalloc.🔼top"><strong>Алгоритмы работы <code>malloc</code>.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#Алгоритмыработыfree.🔼top"><strong>Алгоритмы работы <code>free</code>.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#Выравнивание.🔼top"><strong>Выравнивание.</strong> </a><a href="#top">🔼</a></li>
</ul>
</li>
<li><a href="#variablelengtharray.Функцияalloca.🔼top"><strong>Variable length array. Функция <code>alloca</code>.</strong> </a><a href="#top">🔼</a>
<ul>
<li><a href="#variablelengtharray.🔼top"><strong>Variable length array.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#Функцияalloca.🔼top"><strong>Функция<code>alloca</code>.</strong> </a><a href="#top">🔼</a></li>
</ul>
</li>
<li><a href="#Функцииспеременнымчисломпараметров.🔼top"><strong>Функции с переменным числом параметров.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#Препроцессор.Общиепонятия.Директивыinclude.Простыемакросы.Предопределённыемакросы.Макросыспараметрами.Директивыусловнойкомпиляции.Директивыerrorpragma.Операцияи.🔼top"><strong>Препроцессор. Общие понятия. Директивы <code>include</code>. Простые макросы. Предопределённые макросы. Макросы с параметрами. Директивы условной компиляции. Директивы <code>error</code>, <code>pragma</code>. Операция <code>#</code> и <code>##</code>.</strong> </a><a href="#top">🔼</a>
<ul>
<li><a href="#Препроцессор.Общиепонятия.🔼top"><strong>Препроцессор. Общие понятия.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#Простыемакросы.🔼top"><strong>Простые макросы.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#Директивыусловнойкомпиляции.🔼top"><strong>Директивы условной компиляции.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#Макросыспараметрами.🔼top"><strong>Макросы с параметрами.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#Предопределенныемакросы.🔼top"><strong>Предопределенные макросы.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#Операциии.🔼top"><strong>Операции <code>#</code> и <code>##</code>.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#error.🔼top"><strong><code>#error</code>.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#pragma.🔼top"><strong><code>#pragma</code>.</strong> </a><a href="#top">🔼</a></li>
</ul>
</li>
<li><a href="#Встраиваемыефункции.🔼top"><strong>Встраиваемые функции.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#Библиотеки.🔼top"><strong>Библиотеки.</strong> </a><a href="#top">🔼</a>
<ul>
<li><a href="#Библиотеки."><strong>Библиотеки.</strong></a></li>
<li><a href="#Статическиебиблиотеки.🔼top"><strong>Статические библиотеки.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#Динамическиебиблиотеки.🔼top"><strong>Динамические библиотеки.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#Динамическаякомпоновка.🔼top"><strong>Динамическая компоновка.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#Динамическаязагрузка.🔼top"><strong>Динамическая загрузка.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#Порядоккомпоновкибиблиотеквlinux.🔼top"><strong>Порядок компоновки библиотек в <strong>Linux</strong>.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#Видимостьфункцийвlinuxиwindows.🔼top"><strong>Видимость функций в <strong>Linux</strong> и <strong>Windows</strong>.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#Позиционныйизависимыйкод.gotиplt.🔼top"><strong>Позиционный и зависимый код. <strong>GOT</strong> и <strong>PLT</strong>.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#Подходыкреализациифункцийкоторымтребуетсясоздатьбуфердинамически.🔼top"><strong>Подходы к реализации функций, которым требуется создать буфер динамически.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#Приложениенаpython.Использованиемодуляctypesнапримерефункциицелочисленногосложенияиделения.🔼top"><strong>Приложение на <strong>Python</strong>. Использование модуля <code>ctypes</code> на примере функции целочисленного сложения и деления.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#Приложениенаpython.Использованиемодуляctypesнапримерефункцийобработкимассивов.🔼top"><strong>Приложение на <strong>Python</strong>. Использование модуля <code>ctypes</code> на примере функций обработки массивов.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#Приложениенаpython.Обработкамассивоввмодулерасширения.🔼top"><strong>Приложение на <strong>Python</strong>. Обработка массивов в модуле расширения.</strong> </a><a href="#top">🔼</a></li>
</ul>
</li>
<li><a href="#АТДмодульразновидностимодулей.🔼top"><strong>АТД, модуль, разновидности модулей.</strong> </a><a href="#top">🔼</a>
<ul>
<li><a href="#АО-стекцелыхчисел.🔼top"><strong>АО - стек целых чисел.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#АТД-стекцелыхчисел.🔼top"><strong>АТД - стек целых чисел.</strong> </a><a href="#top">🔼</a></li>
</ul>
</li>
<li><a href="#Спискиядраlinuxидеяосновныемоментыиспользования.🔼top"><strong>Списки ядра Linux, идея, основные моменты использования.</strong> </a><a href="#top">🔼</a></li>
<li><a href="#Спискиядраlinuxидеяосновныемоментыреализации.🔼top"><strong>Списки ядра Linux, идея, основные моменты реализации.</strong> </a><a href="#top">🔼</a></li>
</ul>
</div>


  <style>
    h1 
    {
      color: red;
    }
    h2 
    {
      color: orange;
    }
    h3, h4, h5, h6 
    {
      color: red;
    }
    a 
    {
      text-decoration: none;
    }
  </style>


<h1 id="Указательнаvoid.Стандартныефункцииобработкиобластейпамяти.🔼top"><strong>Указатель на void. Стандартные функции обработки областей памяти.</strong> <a href="#top">🔼</a></h1>

<h2 id="Указательнаvoid.🔼top"><strong>Указатель на void.</strong> <a href="#top">🔼</a></h2>

<p>Тип указатель <code>void</code> (обобщённый указатель) используется при неизвестном типе объекта:</p>

<ul>
<li>Cсылка на произвольный участок памяти, вне зависимости от расположенных там объектов:</li>
</ul>

<pre><code class="C hljs language-C" data-highlighted="yes"><span class="hljs-type">double</span> d = <span class="hljs-number">5.0</span>;
<span class="hljs-type">char</span> c = <span class="hljs-string">'c'</span>;

<span class="hljs-type">void</span> *pd = &amp;d;
<span class="hljs-type">void</span> *pc = &amp;c;
</code></pre>

<ul>
<li>Передача в функцию указателя на объект любого типа.</li>
</ul>

<pre><code class="C hljs language-C" data-highlighted="yes"><span class="hljs-type">ptrdiff_t</span> <span class="hljs-title function_">cmp_int</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *l, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *r)</span>
{	
	<span class="hljs-type">const</span> <span class="hljs-type">int</span> *pl = l;
	<span class="hljs-type">const</span> <span class="hljs-type">int</span> *pr = r;

	<span class="hljs-keyword">return</span> *pl - *pr;
}

...

qsort(arr, <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]),
<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>), cmp_int);
</code></pre>

<p><strong>Особенности:</strong></p>

<p>В языке Си допускается присваивание <code>void*</code> указателю любого другого типа (и наоборот) без явного преобразования типа указателя:</p>

<pre><code class="C hljs language-C" data-highlighted="yes"><span class="hljs-type">double</span> d = <span class="hljs-number">5.0</span>;
<span class="hljs-type">double</span> *pd = &amp;d;
<span class="hljs-type">void</span> *pd = pd;

pd = pv;
</code></pre>

<p><code>void*</code> нельзя разыменовывать:</p>

<pre><code class="C hljs language-C" data-highlighted="yes"><span class="hljs-type">double</span> d = <span class="hljs-number">5.0</span>;
<span class="hljs-type">void</span> *pv = &amp;d;

<span class="hljs-comment">// ERR: fpritnf(stdout, "%lf", *pv);</span>
fputc(NEWLINE, <span class="hljs-built_in">stdout</span>);
</code></pre>

<p>К <code>void*</code> не применима адресная арифметика:</p>

<pre><code class="C hljs language-C" data-highlighted="yes"> <span class="hljs-type">double</span> d = <span class="hljs-number">5.0</span>;
 <span class="hljs-type">void</span> *pv = &amp;d;
 
 <span class="hljs-comment">// ERR: pv++;</span>
</code></pre>

<h2 id="Стандартныефункцииобработкиобластейпамяти.🔼top"><strong>Стандартные функции обработки областей памяти.</strong> <a href="#top">🔼</a></h2>

<p><code>memcmp</code></p>

<p><strong>Описание:</strong></p>

<p>Лексикографически сравнивает первые <code>n</code> байт объектов, на которые указывают <code>s1</code> и <code>s2</code>.</p>

<ul>
<li><code>rc &lt; 0</code> — первый отличающийся байт в <code>s1</code> меньше, чем в <code>s2</code>;</li>
<li><code>rc == 0</code> — первые <code>n</code> байт в <code>s1</code> и <code>s2</code> идентичны;</li>
<li><code>rc &gt; 0</code> — первый отличающийся байт в <code>s1</code> больше, чем в <code>s2</code>.</li>
</ul>

<p><strong>Прототип:</strong></p>

<pre><code class="C hljs language-C" data-highlighted="yes"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">memcmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *s1, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *s2, 
<span class="hljs-type">size_t</span> n)</span>;
</code></pre>

<p><strong>Пример:</strong></p>

<pre><code class="C hljs language-C" data-highlighted="yes"><span class="hljs-type">int</span> arr1[<span class="hljs-number">10</span>] = { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
<span class="hljs-type">int</span> arr2[<span class="hljs-number">10</span>] = { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>};

<span class="hljs-type">int</span> rc = <span class="hljs-built_in">memcmp</span>(arr1, arr2, <span class="hljs-number">5</span>);
</code></pre>

<p><code>memmove</code></p>

<p><strong>Описание:</strong></p>

<ul>
<li>Копирует <code>n</code> символов из объекта, на который указывает <code>s2</code> в объект, на который указывает <code>s1</code>;</li>
<li>Копирование происходит путём создания временного массива из <code>n</code> символов объекта, на который указывает <code>s2</code>;</li>
<li>Массив не перекрывает объекты, на которые указывают <code>s1</code> и <code>s2</code>;</li>
<li>Далее из временного массива данные котируются в объект, на который указывает <code>s1</code>.</li>
</ul>

<p><strong>Прототип:</strong></p>

<pre><code class="C hljs language-C" data-highlighted="yes"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span>

<span class="hljs-type">void</span> *<span class="hljs-title function_">memmove</span><span class="hljs-params">(<span class="hljs-type">void</span> *s1, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *s2,
<span class="hljs-type">size_t</span> n)</span>;
</code></pre>

<p><strong>Пример:</strong></p>

<pre><code class="C hljs language-C" data-highlighted="yes"><span class="hljs-type">char</span> str1[<span class="hljs-number">10</span>] = <span class="hljs-string">"foo"</span>;
<span class="hljs-type">char</span> str2[<span class="hljs-number">10</span>] = <span class="hljs-string">"f"</span>;

memmove(str1 + <span class="hljs-built_in">strlen</span>(str1), str2,
<span class="hljs-built_in">strlen</span>(str2));
</code></pre>

<p><code>memcpy</code></p>

<p><strong>Описание:</strong></p>

<p>Копирует <code>n</code> символов из объекта, на который указывает <code>s2</code>, в объект на который указывает <code>s1</code>. Объекты перекрыты — поведение неопределенно.</p>

<p><strong>Прототип:</strong></p>

<pre><code class="C hljs language-C" data-highlighted="yes"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span>

<span class="hljs-type">void</span> *<span class="hljs-title function_">memcpy</span><span class="hljs-params">(<span class="hljs-type">void</span> *<span class="hljs-keyword">restrict</span> s1,
<span class="hljs-type">const</span> <span class="hljs-type">void</span> *<span class="hljs-keyword">restrict</span> s2, <span class="hljs-type">size_t</span> n)</span>;
</code></pre>

<p><strong>Пример:</strong></p>

<pre><code class="C hljs language-C" data-highlighted="yes"><span class="hljs-type">char</span> str1[<span class="hljs-number">5</span>] = <span class="hljs-string">"foo"</span>;
<span class="hljs-type">char</span> str2[<span class="hljs-number">5</span>];

<span class="hljs-built_in">memcpy</span>(str2, str1, <span class="hljs-built_in">strlen</span>(str1) + <span class="hljs-number">1</span>);
</code></pre>

<p><code>memset</code></p>

<p><strong>Описание:</strong></p>

<p>Копирует значение <code>c</code> (преобразованное в беззнаковый символ) в каждый из первых <code>n</code> символов объекта, на который указывает <code>s</code>.</p>

<p><strong>Прототип:</strong></p>

<pre><code class="C hljs language-C" data-highlighted="yes"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span>

<span class="hljs-type">void</span> *<span class="hljs-title function_">memset</span><span class="hljs-params">(<span class="hljs-type">void</span> *s, <span class="hljs-type">int</span> c, <span class="hljs-type">size_t</span> n)</span>;
</code></pre>

<p><strong>Пример:</strong></p>

<pre><code class="C hljs language-C" data-highlighted="yes"><span class="hljs-type">char</span> str[<span class="hljs-number">10</span>];

<span class="hljs-built_in">memset</span>(str, <span class="hljs-string">'*'</span>, <span class="hljs-keyword">sizeof</span>(str) - <span class="hljs-number">1</span>);
str[<span class="hljs-keyword">sizeof</span>(str) - <span class="hljs-number">1</span>] = NULL_CHAR;
</code></pre>

<div style="page-break-after: always;"></div>

<h1 id="Функциидинамическоговыделенияпамяти.🔼top"><strong>Функции динамического выделения памяти.</strong> <a href="#top">🔼</a></h1>

<p><strong>Общие «свойства» функций <code>malloc</code>, <code>calloc</code>, <code>realloc</code>.</strong></p>

<ul>
<li>Указанные функции не создают переменную, а лишь выделяют область памяти. Результат — адрес расположения этой области в памяти компьютера, т. е. указатель.</li>
<li>Ни одна из функций не знает тип располагаемых данных в выделенном блоке и возвращается указатель на <code>void</code>.</li>
<li>Блок памяти не удалось выделить — <code>NULL</code>.</li>
<li>После использования блок памяти надо освободить при помощи <code>free</code>.</li>
</ul>

<p><code>malloc</code></p>

<p><strong>Описание:</strong></p>

<p>Выделяет место для объекта размером <code>size</code> без инициализации.</p>

<p><strong>Прототип:</strong></p>

<pre><code class="C hljs language-C" data-highlighted="yes"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-type">void</span> *<span class="hljs-title function_">malloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span>;
</code></pre>

<p><code>calloc</code></p>

<p><strong>Описание:</strong></p>

<p>Выделяет место для массива объектов размером <code>nmemb</code>, каждый из которых имеет размер <code>size</code>, c инициализацией нулевыми битами.</p>

<p><strong>Прототип:</strong></p>

<pre><code class="C hljs language-C" data-highlighted="yes"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-type">void</span> *<span class="hljs-title function_">calloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> nmemb, <span class="hljs-type">size_t</span> size)</span>;
</code></pre>

<p><code>free</code></p>

<p><strong>Описание:</strong></p>

<p>Деаллоцирует пространство, на которое указывает <code>ptr</code>, делая его доступным для дальнейшего выделения.</p>

<ul>
<li><code>ptr == NULL</code> — ничего не происходит.</li>
<li><code>ptr</code> указывает на объект, полученный минуя <code>calloc</code>, <code>malloc</code>, <code>realloc</code> — поведение неопределенно (как и в <code>realloc</code>).</li>
</ul>

<p><strong>Прототип:</strong></p>

<pre><code class="C hljs language-C" data-highlighted="yes"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-type">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr)</span>;
</code></pre>

<p><code>realloc</code></p>

<p><strong>Описание:</strong></p>

<p>Деаллоцирует объект, на который указывает <code>ptr</code> и возвращает указатель на новый объект размером <code>size</code></p>

<ul>
<li><code>ptr == NULL</code> и <code>size != 0</code> — аналог <code>malloc</code>;</li>
<li><code>ptr != NULL</code> и <code>size == 0</code> — аналог <code>free</code>;</li>
<li><code>ptr != NULL</code> и <code>size != 0</code> — <code>realloc</code> перевыделяет ранее выделенный блок памяти, на который указывает <code>ptr</code>, делая его размер равным <code>size</code> байт. В худшем случае алгоритм таков:</li>
<li>выделить новую область памяти;</li>
<li>скопировать данные из старой в новую область;</li>
<li>освободить старую область.</li>
</ul>

<p><strong>Прототип:</strong></p>

<pre><code class="C hljs language-C" data-highlighted="yes"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-type">void</span> *<span class="hljs-title function_">realloc</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> size)</span>;
</code></pre>

<p><strong>Типичная ошибка вызова <code>realloc</code>.</strong></p>

<p>Запрашиваемый блок памяти выделить не удалось, <code>realloc</code> вернула <code>NULL</code>, однако <code>ptr</code> не будет освобождён. Во избежание используем временную переменную.</p>

<pre><code class="C hljs language-C" data-highlighted="yes"><span class="hljs-comment">// ERR: pa = realloc(pa, 2 * n);</span>
<span class="hljs-type">void</span> *temp = <span class="hljs-built_in">realloc</span>(pa, <span class="hljs-number">2</span> * n);

<span class="hljs-keyword">if</span> (temp != <span class="hljs-literal">NULL</span>)
{
	pa = temp;
}
<span class="hljs-keyword">else</span>
{
	<span class="hljs-comment">// Обработка ошибочной ситуации</span>
}
</code></pre>

<p><strong>Функция выделения памяти и явное приведение типа: за и против.</strong></p>

<pre><code class="C hljs language-C" data-highlighted="yes"><span class="hljs-type">int</span> *arr = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(n * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));
</code></pre>

<table>
<colgroup>
<col>
<col>
</colgroup>

<thead>
<tr>
	<th> Плюсы              </th>
	<th> Минусы           </th>
</tr>
</thead>

<tbody>
<tr>
	<td> Компиляция с помощью C++ компилятора.      </td>
	<td> Начиная с ANSI C приведение не нужно.      </td>
</tr>
<tr>
	<td> У функции <code>malloc</code> до стандарта ANSI C был другой прототип:<br> <code>char *malloc(size_t size);</code> </td>
	<td> Может скрыть ошибку, если забыли подключить <code>&lt;stdlib.h&gt;</code>.  </td>
</tr>
<tr>
	<td> Дополнительная «проверка» аргументов разработчиком.   </td>
	<td> В случае изменения типа указателя придётся менять тип в приведении. </td>
</tr>
</tbody>
</table>

<p><strong>Особенности выделения 0 байт памяти.</strong></p>

<p>Результат вызова функций <code>malloc</code>, <code>calloc</code> или <code>realloc</code> при запросе нулевого размера блока зависит от реализации:</p>

<ul>
<li>вернется <code>NULL</code>;</li>
<li>вернется «нормальный» указатель, но его нельзя будет использовать для разыменования.</li>
</ul>

<p>Поэтому перед вызовом этих функций нужно убедиться в запросе ненулевого размера блока.</p>

<div style="page-break-after: always;"></div>

<h1 id="Выделенияпамятиподдинамическиймассив.Типичныеошибкиприработесдинамическойпамятью.🔼top"><strong>Выделения памяти под динамический массив. Типичные ошибки при работе с динамической памятью.</strong><a href="#top">🔼</a></h1>

<p><strong>Способы возвращения динамического массива из функции.</strong></p>

<ul>
<li>Как возвращаемое значение:</li>
</ul>

<pre><code class="C hljs language-C" data-highlighted="yes"><span class="hljs-type">int</span> *<span class="hljs-title function_">create_array</span><span class="hljs-params">(FILE *f, <span class="hljs-type">size_t</span> *n)</span>;

...

<span class="hljs-type">int</span> *arr;
<span class="hljs-type">size_t</span> n;
arr = create_array(f, &amp;n);
</code></pre>

<ul>
<li>Как параметр функции:</li>
</ul>

<pre><code class="C hljs language-C" data-highlighted="yes"><span class="hljs-type">int</span> <span class="hljs-title function_">create_array</span><span class="hljs-params">(FILE *f, <span class="hljs-type">int</span> **arr, <span class="hljs-type">size_t</span> *n)</span>;

...

<span class="hljs-type">int</span> *arr, rc;
<span class="hljs-type">size_t</span> n;
rc = create_array(f, &amp;arr, &amp;n);
</code></pre>

<p><strong>Типичные ошибки при работе с динамической памятью.</strong></p>

<ul>
<li>Неверный расчёт количества динамической памяти:</li>
</ul>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">char</span> *str;
str = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">5</span>);
<span class="hljs-built_in">strcpy</span>(str, <span class="hljs-string">"Hello"</span>);
</code></pre>

<ul>
<li>Отсутствие проверки успешности выделения памяти:</li>
</ul>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">int</span> *arr;
arr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">10000</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));
arr[<span class="hljs-number">0</span>] = <span class="hljs-number">5</span>;
</code></pre>

<ul>
<li>Утечки памяти:</li>
</ul>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">int</span> *arr;
arr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">5</span>);
...
<span class="hljs-comment">// ERR: Не освободили</span>
</code></pre>

<p><strong>Логические ошибки:</strong></p>

<ul>
<li>Дикий указатель:</li>
</ul>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">int</span> *ptr;
*ptr = <span class="hljs-number">5</span>;
</code></pre>

<ul>
<li>Висячий указатель:</li>
</ul>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">int</span> *ptr;
ptr = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));
<span class="hljs-built_in">free</span>(ptr);
*ptr = <span class="hljs-number">5</span>;
</code></pre>

<ul>
<li>Изменение указателя, возвращенного функцией выделения памяти:</li>
</ul>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">int</span> *ptr;
ptr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">5</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));
ptr++;
<span class="hljs-built_in">free</span>(ptr);
</code></pre>

<ul>
<li>Двойное освобождение памяти:</li>
</ul>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">int</span> *ptr;
ptr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">5</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));
<span class="hljs-built_in">free</span>(ptr);
<span class="hljs-built_in">free</span>(ptr);
</code></pre>

<ul>
<li>Освобождение невыделенной или нединамической памяти:</li>
</ul>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">int</span> x;
<span class="hljs-built_in">free</span>(&amp;x);
</code></pre>

<ul>
<li>Выход за границы динамического массива:</li>
</ul>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">int</span> *arr;
arr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">5</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));
arr[<span class="hljs-number">5</span>] = <span class="hljs-number">42</span>;
</code></pre>

<p>И прочее...</p>

<p><strong>Подходы к обработке ситуации отсутствия свободной памяти при выделении.</strong></p>

<ol>
<li>Возвращение ошибки — функция выделения памяти возвращает специальный код в случае неудачи (например,<code>NULL</code> в <code>malloc</code>, <code>calloc</code>, <code>realloc</code>);</li>
<li>Ошибка сегментации — неудача выделения памяти игнорируется, разыменовывание <code>NULL</code> вызывает ошибку.</li>
<li>Аварийное завершение — реализация функции обёртки <code>xmalloc</code>, которая в случае неудачи вызывает <code>abort()</code> или <code>exit()</code>;</li>
<li>Восстановление — попытка освобождения ранее выделенной памяти или уменьшение использованния ресурсов для повторного выделения памяти. (например <code>xmalloc</code> из <code>git</code>).</li>
</ol>

<ul>
<li>Как возвращаемое значение:</li>
</ul>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">int</span> *<span class="hljs-title function_">create_array</span><span class="hljs-params">(FILE *f, <span class="hljs-type">size_t</span> *n)</span>
{
    <span class="hljs-type">int</span> *arr = <span class="hljs-literal">NULL</span>;
    <span class="hljs-type">int</span> rc = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">NULL</span> || n == <span class="hljs-literal">NULL</span>)
    {
        rc = <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">else</span>
    {
        *n = <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> tmp;

        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">fscanf</span>(f, <span class="hljs-string">"%d"</span>, &amp;tmp) == <span class="hljs-number">1</span>)
        {
            (*n)++;
        }

        rewind(f);

        <span class="hljs-keyword">if</span> ((arr = <span class="hljs-built_in">malloc</span>((*n) * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>))) == <span class="hljs-literal">NULL</span>)
        {
            rc = <span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; *n &amp;&amp; rc == <span class="hljs-number">0</span>; i++)
            {
                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fscanf</span>(f, <span class="hljs-string">"%d"</span>, &amp;arr[i]) != <span class="hljs-number">1</span>)
                {
                    <span class="hljs-built_in">free</span>(arr);
                    arr = <span class="hljs-literal">NULL</span>;
                    rc = <span class="hljs-number">1</span>;
                }
            }
        }
    }

    <span class="hljs-keyword">return</span> (rc == <span class="hljs-number">0</span> ? arr : <span class="hljs-literal">NULL</span>);
}
</code></pre>

<ul>
<li>Как параметр функции:</li>
</ul>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">int</span> <span class="hljs-title function_">create_array</span><span class="hljs-params">(FILE *f, <span class="hljs-type">int</span> **arr, <span class="hljs-type">size_t</span> *n)</span>
{
    <span class="hljs-type">int</span> rc = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">NULL</span> || arr == <span class="hljs-literal">NULL</span> || n == <span class="hljs-literal">NULL</span>)
    {
        rc = <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">else</span>
    {
        *n = <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> tmp;

        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">fscanf</span>(f, <span class="hljs-string">"%d"</span>, &amp;tmp) == <span class="hljs-number">1</span>)
        {
            (*n)++;
        }

        rewind(f);

        <span class="hljs-keyword">if</span> ((*arr = <span class="hljs-built_in">malloc</span>((*n) * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>))) == <span class="hljs-literal">NULL</span>)
        {
            rc = <span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; *n &amp;&amp; rc == <span class="hljs-number">0</span>; i++)
            {
                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fscanf</span>(f, <span class="hljs-string">"%d"</span>, &amp;((*arr)[i])) != <span class="hljs-number">1</span>)
                {
                    <span class="hljs-built_in">free</span>(*arr);
                    *arr = <span class="hljs-literal">NULL</span>;
                    rc = <span class="hljs-number">1</span>;
                }
            }
        }
    }

    <span class="hljs-keyword">return</span> rc;
}
</code></pre>

<div style="page-break-after: always;"></div>

<h1 id="Указателинафункции.Функцияqsort.🔼top"><strong>Указатели на функции. Функция <code>qsort</code>.</strong><a href="#top">🔼</a></h1>

<p>Указатели на функцию используются для передачи одной функции в качестве параметра другой функции.</p>

<p>С помощью указателей на функцию реализуются:</p>

<ul>
<li>Функции обратного вызова — передача исполняемого кода в качестве одного из параметров другого кода;</li>
<li>Таблицы переходов;</li>
<li>Динамическое связывание.</li>
</ul>

<p>Объявление указателя на функцию:</p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">double</span> <span class="hljs-title function_">trapezium</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b, <span class="hljs-type">int</span> n, 
<span class="hljs-type">double</span>(*func)(<span class="hljs-type">double</span>))</span>;
</code></pre>

<p>Получение адреса функции (инициализация):</p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">double</span> result = trapezium(<span class="hljs-number">0</span>, <span class="hljs-number">3.14</span>, <span class="hljs-number">25</span>, &amp;<span class="hljs-built_in">sin</span>);
</code></pre>

<p>Вызов функции по указателю:</p>

<pre><code class="c hljs language-c" data-highlighted="yes">y = (*func) (x); <span class="hljs-comment">// ~ y = func(x);</span>
</code></pre>

<p><strong><code>qsort</code></strong></p>

<p><strong>Описание:</strong></p>

<ul>
<li>Сортирует массив объектов <code>nmemb</code>, на начальный элемент которого указывает <code>base</code>. Размер у каждого объекта — <code>size</code>;</li>
<li>Содержимое массива сортируется по возрастанию по критерию функции сравнения, на которую указывает функция <code>compar</code>;</li>
<li><code>compar</code> принимает два аргумента, указывающих на сравнимые объекты;</li>
<li><code>compar</code> должно вернуть число <strong>&gt;0</strong>, <strong>=0</strong>, <strong>&lt;0</strong>, где первый аргумент соответственно меньше, равен, больше второго (-ому).</li>
</ul>

<p><strong>Прототип:</strong></p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-type">void</span> <span class="hljs-title function_">qsort</span><span class="hljs-params">(<span class="hljs-type">void</span> *base, <span class="hljs-type">size_t</span> nmemb, <span class="hljs-type">size_t</span> size,
<span class="hljs-type">int</span> (*compar)(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *))</span>;
</code></pre>

<p><strong>Пример:</strong></p>

<pre><code class="C hljs language-C" data-highlighted="yes"><span class="hljs-type">ptrdiff_t</span> <span class="hljs-title function_">cmp_int</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *l, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *r)</span>
{	
	<span class="hljs-type">const</span> <span class="hljs-type">int</span> *pl = l;
	<span class="hljs-type">const</span> <span class="hljs-type">int</span> *pr = r;

	<span class="hljs-keyword">return</span> *pl - *pr;
}

...

qsort(arr, <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]),
<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>), cmp_int);
</code></pre>

<p><strong>Особенности использования указателей на функцию (c учётом адресной арифметики).</strong></p>

<p>По стандарту выражение из имени функции неявно преобразуется в указатель на функцию.</p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;
...
<span class="hljs-type">int</span> (*p1)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) = add;
</code></pre>

<p>Операция <code>&amp;</code> для функции возвращает указатель на функцию, но из особенности выше это лишняя операция.</p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">int</span> (*p2)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) = &amp;add;
</code></pre>

<p>Операция <code>*</code> для указателя на функцию возвращает саму функцию, а она преобразуется в указатель на функцию.</p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">int</span> (*p3)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) = *add;
<span class="hljs-type">int</span> (*p4)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) = ****add;
</code></pre>

<p>Указатели на функцию можно сравнивать:</p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-keyword">if</span> (p1 == add)
{
	...
}
</code></pre>

<p>Указатель на функцию может быть типом возвращаемого значения функции:</p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">int</span> (*get_action(<span class="hljs-type">char</span> ch))(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>);
<span class="hljs-comment">// typedef приходит на помощь :)</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*<span class="hljs-type">ptr_action_t</span>)</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>;
<span class="hljs-type">ptr_action_t</span> <span class="hljs-title function_">get_action</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span>;
</code></pre>

<p><strong>Указатели на функцию и <code>*void</code>.</strong></p>

<p>По стандарту указатель на функцию не преобразуется к <code>*void</code> и наоборот.</p>

<p>POSIX требует возможность такого преобразования при работе с динамическими библиотеками.</p>

<div style="page-break-after: always;"></div>

<h1 id="Утилитаmake.Назначение.Простойсценарийсборки.🔼top"><strong>Утилита Make. Назначение. Простой сценарий сборки.</strong><a href="#top">🔼</a></h1>

<h2 id="Утилитаmake.Назначение.🔼top"><strong>Утилита Make. Назначение.</strong> <a href="#top">🔼</a></h2>

<p><code>make</code> — утилита, автоматизирующая процесс преобразования файлов из одной формы в
другую. Это может быть не только процесс компиляции программы, например, автоматизация
<code>*.tex</code> → <code>*.pdf</code>.</p>

<p>Для своей работы <code>make</code> использует:</p>

<ol>
<li>Сценарий сборки проекта — make-файл, содержащий описание зависимостей внутри
проекта и описание команд, с помощью которых на основе одних файлов можно
получить другие файлы.</li>
<li>Время последней модификации файла, запрошенное у файловой системы, используется
для определения необходимости пересборки файла.</li>
</ol>

<p><strong>Разновидности утилиты make</strong>.</p>

<ul>
<li><code>GNU Make</code> (рассматриваем в курсе).</li>
<li><code>BSD Make</code>.</li>
<li><code>Microsoft Make</code> (<code>nmake</code>).</li>
</ul>

<p>У всех трёх разновидностей одна идеология и разный синтаксис.</p>

<h2 id="Простойсценарийсборки.🔼top"><strong>Простой сценарий сборки.</strong> <a href="#top">🔼</a></h2>

<p>Файл называется makefile / Makefile.</p>

<p>Внутри сценария сборки проекта в основном находятся так называемые правила:</p>

<ol>
<li>Цель — имя файла, получаемого в результате выполнения правила. Может
представлять собой имя действия, которое утилита make выполнит при выполнении
этого правила.</li>
<li>Зависимости — имена файлов, на основе которых должен быть получен файл,
являющийся целью правила.</li>
<li>Команды — shell-команды, выполняемые для достижения цели.</li>
</ol>

<p>Пример структуры правила:</p>

<pre><code class="make hljs language-erlang" data-highlighted="yes">цель зависимость_1 ... зависимость_N:
	команда_1
	...
	команда_M
</code></pre>

<p>Описание команд начинается с табуляции.</p>

<p><strong>Особенности выполнения команд.</strong></p>

<ul>
<li>Ненулевой код возврата может прервать выполнение сценария.</li>
<li>Каждая команда выполняется в своем <code>shell</code>.</li>
</ul>

<p><strong>Простой сценарий сборки + алгоритм.</strong></p>

<pre><code class="make hljs language-yaml" data-highlighted="yes"><span class="hljs-attr">app.exe :</span> <span class="hljs-string">file_1.o</span> <span class="hljs-string">file_2.o</span> <span class="hljs-string">main.o</span>
	<span class="hljs-string">gcc</span> <span class="hljs-string">-o</span> <span class="hljs-string">app.exe</span> <span class="hljs-string">file_1.o</span> <span class="hljs-string">file_2.o</span> <span class="hljs-string">main.o</span>

<span class="hljs-attr">test_app.exe :</span> <span class="hljs-string">file_1.o</span> <span class="hljs-string">file_2.o</span> <span class="hljs-string">test_file.o</span>
	<span class="hljs-string">gcc</span> <span class="hljs-string">-o</span> <span class="hljs-string">test_app.exe</span> <span class="hljs-string">file_1.o</span> <span class="hljs-string">file_2.o</span> <span class="hljs-string">test_file.o</span>

<span class="hljs-attr">file_1.o :</span> <span class="hljs-string">file_1.c</span> <span class="hljs-string">file_1.h</span>
	<span class="hljs-string">gcc</span> <span class="hljs-string">-std=c99</span> <span class="hljs-string">-Wall</span> <span class="hljs-string">-Werror</span> <span class="hljs-string">-pedantic</span> <span class="hljs-string">-c</span> <span class="hljs-string">file_1.c</span>

<span class="hljs-attr">file_2.o :</span> <span class="hljs-string">file_2.c</span> <span class="hljs-string">file_2.h</span>
	<span class="hljs-string">gcc</span> <span class="hljs-string">-std=c99</span> <span class="hljs-string">-Wall</span> <span class="hljs-string">-Werror</span> <span class="hljs-string">-pedantic</span> <span class="hljs-string">-c</span> <span class="hljs-string">file_2.c</span>

<span class="hljs-attr">main.o :</span> <span class="hljs-string">main.c</span> <span class="hljs-string">file_1.h</span> <span class="hljs-string">file_2.h</span>
	<span class="hljs-string">gcc</span> <span class="hljs-string">-std=c99</span> <span class="hljs-string">-Wall</span> <span class="hljs-string">-Werror</span> <span class="hljs-string">-pedantic</span> <span class="hljs-string">-c</span> <span class="hljs-string">main.c</span>

<span class="hljs-attr">test_file.o :</span> <span class="hljs-string">test_file.c</span> <span class="hljs-string">file_1.h</span> <span class="hljs-string">file_2.h</span>
	<span class="hljs-string">gcc</span> <span class="hljs-string">-std=c99</span> <span class="hljs-string">-Wall</span> <span class="hljs-string">-Werror</span> <span class="hljs-string">-pedantic</span> <span class="hljs-string">-c</span> <span class="hljs-string">test_file.c</span>

<span class="hljs-attr">clean :</span>
	<span class="hljs-string">rm</span> <span class="hljs-string">*.o</span> <span class="hljs-string">*.exe</span>
</code></pre>

<p>Текущая ситуация: есть проект без объектных и исполняемых файлов.</p>

<ol>
<li>Запускаем утилиту <code>make</code>.</li>
<li>Утилита читает содержимое сценария сборки и находит цель по умолчанию — цель,
связанная с первым правилом в сценарии сборки (в примере выше это <code>app.exe</code>).</li>
<li>Утилита читает правило и видит, что для получения файла <code>app.exe</code> необходимо найти файлы проекта <code>file_1.o</code>, <code>file_2.o</code>, <code>main.o</code>.</li>
<li>Так как файлы отсутствуют, утилита <code>make</code> берёт имя файла и ищет способ его получения.</li>
<li>Находит правило и видит, что для получения каждого объектного файла нужны соответствующие файлы с расширением <code>.c</code> и <code>.h</code>.</li>
<li>Эти файлы существуют, значит, объектный файл возможно получить.</li>
<li>Утилита выполняет соответствующую команду и получает объектный файл.</li>
<li>Аналогично происходит со всеми файлами.</li>
<li>Когда все файлы зависимостей присутствуют, выполняется команда получения исполняемого файла.</li>
</ol>

<p><strong>Ключи утилиты <code>make</code>.</strong></p>

<ul>
<li>Указать имя файла сценария сборки (например, compile) — ключ <code>-f</code>.</li>
<li>Полная пересборка проекта — ключ <code>-B</code>.</li>
<li>Формирование всех выполненных команд без их выполнения — ключ <code>-n</code>.</li>
<li>Игнорирование ошибок (приведёт к ошибке компоновки) — ключ <code>-i</code>.</li>
</ul>

<div style="page-break-after: always;"></div> 

<h1 id="Утилитаmake.Назначение.Переменныешаблонныеправила.🔼top"><strong>Утилита <code>Make</code>. Назначение. Переменные, шаблонные правила.</strong><a href="#top">🔼</a></h1>

<h2 id="Утилитаmake.Назначение.🔼top"><strong>Утилита <code>Make</code>. Назначение.</strong> <a href="#top">🔼</a></h2>

<p><code>make</code> — утилита, автоматизирующая процесс преобразования файлов из одной формы в
другую. Это может быть не только процесс компиляции программы, например, автоматизация
<code>*.tex</code> → <code>*.pdf</code>.</p>

<p>Для своей работы <code>make</code> использует:</p>

<ol>
<li>Сценарий сборки проекта — make-файл, содержащий описание зависимостей внутри
проекта и описание команд, с помощью которых на основе одних файлов можно
получить другие файлы.</li>
<li>Время последней модификации файла, запрошенное у файловой системы, используется
для определения необходимости пересборки файла.</li>
</ol>

<p><strong>Разновидности утилиты <code>make</code>.</strong></p>

<ul>
<li><code>GNU Make</code> (рассматриваем в курсе).</li>
<li><code>BSD Make</code>.</li>
<li><code>Microsoft Make</code> (<code>nmake</code>).</li>
</ul>

<p>У всех трёх разновидностей одна идеология и разный синтаксис.</p>

<h2 id="Переменныешаблонныеправила.🔼top"><strong>Переменные, шаблонные правила.</strong> <a href="#top">🔼</a></h2>

<p>Объявление переменной:</p>

<pre><code class="make hljs language-go" data-highlighted="yes">VAR_NAME := value
</code></pre>

<p>Доступ к значению переменной:</p>

<pre><code class="make hljs language-javascript" data-highlighted="yes">$(<span class="hljs-variable constant_">VAR_NAME</span>)
</code></pre>

<p>Пример:</p>

<pre><code class="make hljs language-go" data-highlighted="yes">CC := gcc
CFLAGS := -std=c99 -Wall -Werror -Wpedantic

OBJS := file_1.o file_2.o

app.exe : $(OBJS) main.o
	$(CC) -o app.exe $(OBJS) main.o
...
</code></pre>

<p><strong>Фиктивные цели.</strong></p>

<p>Могут встречаться цели, не связанные с файлами. Их называют фиктивными. Это может быть
установка, удаление, очистка и прочее.</p>

<p>Чтобы <code>make</code> не пыталась интерпретировать имена таких правил как файлы, используется
атрибут <code>.PHONY</code> :</p>

<pre><code class="make hljs language-undefined" data-highlighted="yes">.PHONY: clean
</code></pre>

<p><strong>Неявные правила и переменные.</strong></p>

<ul>
<li>Просмотр неявных правил — ключ <code>-p</code>.</li>
<li>Запрет неявных правил — ключ <code>-r</code>.</li>
</ul>

<p>В примере <code>main.o</code> создастся неявно без правила:</p>

<pre><code class="make hljs language-javascript" data-highlighted="yes">app.<span class="hljs-property">exe</span>: $(<span class="hljs-variable constant_">OBJS</span>) main.<span class="hljs-property">o</span>
	$(<span class="hljs-variable constant_">CC</span>) -o greeting.<span class="hljs-property">exe</span> $(<span class="hljs-variable constant_">OBJS</span>) main.<span class="hljs-property">o</span>
</code></pre>

<p><strong>Автоматические переменные и их использование.</strong></p>

<p>Эти переменные автоматически получают определённые значения перед тем, как будет
выполнена команда правила.
Наиболее часто используемые имена автоматических переменных:</p>

<ul>
<li><code>$^</code> — список зависимостей.</li>
<li><code>$@</code> — имя цели.</li>
<li><code>$&lt;</code> — первая зависимость.</li>
</ul>

<p><strong>Шаблонные правила.</strong></p>

<p><code>%</code> задает зависимость от подстановки в цели.</p>

<pre><code class="makefile hljs language-erlang" data-highlighted="yes"><span class="hljs-comment">%.расширение_файлов_целей : </span>
<span class="hljs-comment">%.расширение_файлов_зависимостей</span>
	команда_1
	...
	команда_M
</code></pre>

<p>В правилах задает зависимость от всех файлов по маске:</p>

<pre><code class="makefile hljs language-ruby" data-highlighted="yes">%.<span class="hljs-symbol">o:</span> %.c *.h
	<span class="hljs-variable">$(</span><span class="hljs-variable constant_">CC</span>) <span class="hljs-variable">$(</span><span class="hljs-variable constant_">CFLAGS</span>) -c <span class="hljs-variable">$&lt;</span>
</code></pre>

<div style="page-break-after: always;"></div> 

<h1 id="Утилитаmake.Назначение.Условныеконструкцииианализзависимостей.🔼top"><strong>Утилита <code>Make</code>. Назначение. Условные конструкции и анализ зависимостей.</strong> <a href="#top">🔼</a></h1>

<h2 id="Утилитаmake.Назначение.🔼top"><strong>Утилита <code>Make</code>. Назначение.</strong> <a href="#top">🔼</a></h2>

<p><code>make</code> — утилита, автоматизирующая процесс преобразования файлов из одной формы в
другую. Это может быть не только процесс компиляции программы, например, автоматизация
<code>*.tex</code> → <code>*.pdf</code>.</p>

<p>Для своей работы <code>make</code> использует:</p>

<ol>
<li>Сценарий сборки проекта — <code>make</code>-файл, содержащий описание зависимостей внутри
проекта и описание команд, с помощью которых на основе одних файлов можно
получить другие файлы.</li>
<li>Время последней модификации файла, запрошенное у файловой системы, используется
для определения необходимости пересборки файла.</li>
</ol>

<p><strong>Разновидности утилиты <code>make</code>.</strong></p>

<ul>
<li><code>GNU Make</code> (рассматриваем в курсе).</li>
<li><code>BSD Make</code>.</li>
<li><code>Microsoft Make</code> (<code>nmake</code>).</li>
</ul>

<p>У всех трёх разновидностей одна идеология и разный синтаксис.</p>

<h2 id="Условныеконструкцииианализзависимостей.🔼top"><strong>Условные конструкции и анализ зависимостей.</strong> <a href="#top">🔼</a></h2>

<p>Условные конструкции в сценарии сборки. Примеры использования.</p>

<pre><code class="makefile hljs language-perl" data-highlighted="yes">ife<span class="hljs-string">q (условие1, условие2)</span>
	<span class="hljs-comment"># истина</span>
<span class="hljs-keyword">else</span>
	<span class="hljs-comment"># ложь</span>
</code></pre>

<p>Переменные, зависящие от цели.</p>

<pre><code class="makefile hljs language-nginx" data-highlighted="yes"><span class="hljs-attribute">CC</span> := gcc
CFLAGS := -std=c99 -Wall -W<span class="hljs-literal">error</span> -Wpedantic

OBJS := file_1.o file_2.o

<span class="hljs-literal">debug</span> : CFLAGS += -g3
<span class="hljs-literal">debug</span> : app.exe

release : CFLAGS += -DNDEBUG -g0
release : app.exe
</code></pre>

<p>Ручная установка зависимостей</p>

<pre><code class="make hljs language-ruby" data-highlighted="yes">%.<span class="hljs-symbol">o:</span> %.c %.h
	<span class="hljs-variable">$(</span><span class="hljs-variable constant_">CC</span>) -c <span class="hljs-variable">$(</span><span class="hljs-variable constant_">CFLAGS</span>) <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span>
</code></pre>

<p>С помощью компилятора:</p>

<pre><code class="make hljs language-ruby" data-highlighted="yes"><span class="hljs-comment"># C-файлы</span>
<span class="hljs-variable constant_">SRCS</span> <span class="hljs-symbol">:</span>= ...

%.<span class="hljs-symbol">o:</span> %.c
	<span class="hljs-variable">$(</span><span class="hljs-variable constant_">CC</span>) <span class="hljs-variable">$(</span><span class="hljs-variable constant_">CFLAGS</span>) -c <span class="hljs-variable">$&lt;</span>

%.<span class="hljs-symbol">d:</span> %.c
	<span class="hljs-variable">$(</span><span class="hljs-variable constant_">CC</span>) -M <span class="hljs-variable">$&lt;</span> &gt; <span class="hljs-variable">$@</span>

<span class="hljs-keyword">include</span> <span class="hljs-variable">$(</span><span class="hljs-variable constant_">SRCS</span><span class="hljs-symbol">:</span>.c=.d)
</code></pre>

<p>Функции в <code>make</code>.</p>

<p>Вызов:</p>

<pre><code class="make hljs language-javascript" data-highlighted="yes">$(function_name [<span class="hljs-variable language_">arguments</span>])
</code></pre>

<p><code>patsubst</code></p>

<pre><code class="make hljs language-ruby" data-highlighted="yes"><span class="hljs-variable">$(</span>patsubst pattern, replacement, text)
cfiles <span class="hljs-symbol">:</span>= main.c hello.c bye.c

<span class="hljs-comment"># Полностью</span>
objs <span class="hljs-symbol">:</span>= <span class="hljs-variable">$(</span>patsubst %.c, %.o, <span class="hljs-variable">$(</span>cfiles))

<span class="hljs-comment"># Кратко</span>
objs <span class="hljs-symbol">:</span>= <span class="hljs-variable">$(</span><span class="hljs-symbol">cfiles:</span>%.c=%.o)
</code></pre>

<div style="page-break-after: always;"></div>

<h1 id="Динамическиематрицы.Представлениеввидеодномерногомассиваиввидемассивауказателейнастроки.Анализпреимуществинедостатков.🔼top"><strong>Динамические матрицы. Представление в виде одномерного массива и в виде массива указателей на строки. Анализ преимуществ и недостатков.</strong> <a href="#top">🔼</a></h1>

<p>Количество строк:
<span class="math"><mjx-container class="MathJax" jax="SVG" display="true"><svg xmlns="http://www.w3.org/2000/svg" width="5.506ex" height="1.69ex" role="img" focusable="false" viewBox="0 -665 2433.6 747" xmlns:xlink="http://www.w3.org/1999/xlink" style="vertical-align: -0.186ex;"><defs><path id="MJX-1-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-1-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-1-TEX-N-33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D45B" xlink:href="#MJX-1-TEX-I-1D45B"></use></g><g data-mml-node="mo" transform="translate(877.8,0)"><use data-c="3D" xlink:href="#MJX-1-TEX-N-3D"></use></g><g data-mml-node="mn" transform="translate(1933.6,0)"><use data-c="33" xlink:href="#MJX-1-TEX-N-33"></use></g></g></g></svg></mjx-container></span>
Количество столбцов:
<span class="math"><mjx-container class="MathJax" jax="SVG" display="true"><svg xmlns="http://www.w3.org/2000/svg" width="6.135ex" height="1.717ex" role="img" focusable="false" viewBox="0 -677 2711.6 759" xmlns:xlink="http://www.w3.org/1999/xlink" style="vertical-align: -0.186ex;"><defs><path id="MJX-2-TEX-I-1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-2-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-2-TEX-N-34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D45A" xlink:href="#MJX-2-TEX-I-1D45A"></use></g><g data-mml-node="mo" transform="translate(1155.8,0)"><use data-c="3D" xlink:href="#MJX-2-TEX-N-3D"></use></g><g data-mml-node="mn" transform="translate(2211.6,0)"><use data-c="34" xlink:href="#MJX-2-TEX-N-34"></use></g></g></g></svg></mjx-container></span>
Тип элементов матрицы:
<span class="math"><mjx-container class="MathJax" jax="SVG" display="true"><svg xmlns="http://www.w3.org/2000/svg" width="1.593ex" height="1.532ex" role="img" focusable="false" viewBox="0 -677 704 677" xmlns:xlink="http://www.w3.org/1999/xlink" style="vertical-align: 0px;"><defs><path id="MJX-3-TEX-I-1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D447" xlink:href="#MJX-3-TEX-I-1D447"></use></g></g></g></svg></mjx-container></span></p>

<h2 id="Матрицакакодномерныймассив.🔼top"><strong>Матрица как одномерный массив.</strong> <a href="#top">🔼</a></h2>

<figure>
<img src="/Users/dezodorant/Desktop/Скрины/Снимок" alt="">
<figcaption></figcaption>
</figure>

<p><span class="math"><mjx-container class="MathJax" jax="SVG" display="true"><svg xmlns="http://www.w3.org/2000/svg" width="12.705ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 5615.6 1000" xmlns:xlink="http://www.w3.org/1999/xlink" style="vertical-align: -0.566ex;"><defs><path id="MJX-4-TEX-I-1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path><path id="MJX-4-TEX-N-5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path><path id="MJX-4-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path><path id="MJX-4-TEX-N-5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path><path id="MJX-4-TEX-I-1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path><path id="MJX-4-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-4-TEX-I-1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path><path id="MJX-4-TEX-N-2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D44E" xlink:href="#MJX-4-TEX-I-1D44E"></use></g><g data-mml-node="mo" transform="translate(529,0)"><use data-c="5B" xlink:href="#MJX-4-TEX-N-5B"></use></g><g data-mml-node="mi" transform="translate(807,0)"><use data-c="1D456" xlink:href="#MJX-4-TEX-I-1D456"></use></g><g data-mml-node="mo" transform="translate(1152,0)"><use data-c="5D" xlink:href="#MJX-4-TEX-N-5D"></use></g><g data-mml-node="mo" transform="translate(1430,0)"><use data-c="5B" xlink:href="#MJX-4-TEX-N-5B"></use></g><g data-mml-node="mi" transform="translate(1708,0)"><use data-c="1D457" xlink:href="#MJX-4-TEX-I-1D457"></use></g><g data-mml-node="mo" transform="translate(2120,0)"><use data-c="5D" xlink:href="#MJX-4-TEX-N-5D"></use></g><g data-mml-node="mo" transform="translate(2675.8,0)"><use data-c="3D" xlink:href="#MJX-4-TEX-N-3D"></use></g><g data-mml-node="mi" transform="translate(3731.6,0)"><use data-c="1D44E" xlink:href="#MJX-4-TEX-I-1D44E"></use></g><g data-mml-node="mo" transform="translate(4260.6,0)"><use data-c="5B" xlink:href="#MJX-4-TEX-N-5B"></use></g><g data-mml-node="mi" transform="translate(4538.6,0)"><use data-c="1D458" xlink:href="#MJX-4-TEX-I-1D458"></use></g><g data-mml-node="mo" transform="translate(5059.6,0)"><use data-c="5D" xlink:href="#MJX-4-TEX-N-5D"></use></g><g data-mml-node="mo" transform="translate(5337.6,0)"><use data-c="2C" xlink:href="#MJX-4-TEX-N-2C"></use></g></g></g></svg></mjx-container></span> где:
<span class="math"><mjx-container class="MathJax" jax="SVG" display="true"><svg xmlns="http://www.w3.org/2000/svg" width="12.295ex" height="2.032ex" role="img" focusable="false" viewBox="0 -694 5434.4 898" xmlns:xlink="http://www.w3.org/1999/xlink" style="vertical-align: -0.462ex;"><defs><path id="MJX-5-TEX-I-1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path><path id="MJX-5-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-5-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path><path id="MJX-5-TEX-N-22C5" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250Z"></path><path id="MJX-5-TEX-I-1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-5-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path><path id="MJX-5-TEX-I-1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D458" xlink:href="#MJX-5-TEX-I-1D458"></use></g><g data-mml-node="mo" transform="translate(798.8,0)"><use data-c="3D" xlink:href="#MJX-5-TEX-N-3D"></use></g><g data-mml-node="mi" transform="translate(1854.6,0)"><use data-c="1D456" xlink:href="#MJX-5-TEX-I-1D456"></use></g><g data-mml-node="mo" transform="translate(2421.8,0)"><use data-c="22C5" xlink:href="#MJX-5-TEX-N-22C5"></use></g><g data-mml-node="mi" transform="translate(2922,0)"><use data-c="1D45A" xlink:href="#MJX-5-TEX-I-1D45A"></use></g><g data-mml-node="mo" transform="translate(4022.2,0)"><use data-c="2B" xlink:href="#MJX-5-TEX-N-2B"></use></g><g data-mml-node="mi" transform="translate(5022.4,0)"><use data-c="1D457" xlink:href="#MJX-5-TEX-I-1D457"></use></g></g></g></svg></mjx-container></span></p>

<table>
<colgroup>
<col>
<col>
</colgroup>

<thead>
</thead>

<tbody>
<tr>
	<td><strong>Плюсы</strong></td>
	<td><strong>Минусы</strong></td>
</tr>
<tr>
	<td> Простота выделения и освобождения памяти.   </td>
	<td> Отладчик использования памяти не может отследить выход за пределы строки. </td>
</tr>
<tr>
	<td> Возможность использовать как одномерный массив.  </td>
	<td> Нужно писать <code>i * m + j</code> для доступа к элементам двумерного массива.  </td>
</tr>
</tbody>
</table>

<h2 id="Матрицакакмассивуказателей.🔼top"><strong>Матрица как массив указателей.</strong> <a href="#top">🔼</a></h2>

<figure>
<img src="/Users/dezodorant/Desktop/Скрины/Снимок%20экрана%202025-01-29%20в%2006.16.54.png" alt="">
<figcaption></figcaption>
</figure>

<p><strong>Алгоритм выделения памяти:</strong></p>

<p><strong>Вход:</strong></p>

<p><code>n</code>, <code>m</code>.</p>

<p><strong>Выход:</strong></p>

<p><code>p</code> — указатель на массив строк матрицы.</p>

<ol>
<li>Выделить память под массив указателей (<code>p</code>);</li>
<li>Обработать ошибку выделения памяти;</li>
<li>В цикле по количеству строк матрицы (<code>0 &lt;= i &lt; n</code>):</li>
</ol>

<ul>
<li>Выделить память под <code>i</code>-ую строку матрицы (<code>q</code>);</li>
<li>Обработать ошибку выделения памяти;</li>
<li><code>p[i]=q</code>.</li>
</ul>

<p><strong>Алгоритм освобождения памяти:</strong></p>

<p><strong>Вход:</strong></p>

<p>Указатель на массив строк матрицы (<code>p</code>) и
количество строк (<code>n</code>).</p>

<ol>
<li>В цикле по количеству строк матрицы (<code>0 &lt;= i &lt; n</code>): Освободить память из-под <code>i</code>-ой строки матрицы.</li>
<li>Освободить память из-под массива указателей (<code>p</code>).</li>
</ol>

<table>
<colgroup>
<col>
<col>
</colgroup>

<thead>
</thead>

<tbody>
<tr>
	<td><strong>Плюсы</strong></td>
	<td><strong>Минусы</strong></td>
</tr>
<tr>
	<td>   <br>Возможность обмена строки через обмен указателей.<br><br>   </td>
	<td> <br>Сложность выделения и освобождения памяти.<br><br> </td>
</tr>
<tr>
	<td> <br>Отладчик использования памяти может отследить выход за пределы строки.<br><br> </td>
	<td> <br>Память под матрицу «не лежит» одной областью. </td>
</tr>
</tbody>
</table>

<h2 id="Объединениеподходов1.🔼top"><strong>Объединение подходов (1).</strong> <a href="#top">🔼</a></h2>

<figure>
<img src="/Users/dezodorant/Desktop/Скрины/Снимок%20экрана%202025-01-29%20в%2007.19.16.png" alt="">
<figcaption></figcaption>
</figure>

<p><strong>Алгоритм выделения памяти.</strong></p>

<p><strong>Вход</strong>:</p>

<p><code>n</code>, <code>m</code>.</p>

<p><strong>Выход</strong>:</p>

<p>Указатель на массив строк матрицы (<code>p</code>).</p>

<ul>
<li>Выделить память под массив указателей на строки (<code>p</code>);</li>
<li>Обработать ошибку выделения памяти;</li>
<li>Выделить память под данные (т.е. под строки, <code>q</code>);</li>
<li>Обработать ошибку выделения памяти;</li>
<li>В цикле по количеству строк <strong>матрицы</strong> (<code>0 &lt;= i &lt; n</code>);</li>
<li><code>p[i]</code> = адрес <code>i</code>-ой строки в массиве <code>q</code>.</li>
</ul>

<p><strong>Алгоритм освобождения памяти.</strong></p>

<p><strong>Вход</strong>:</p>

<p>Указатель на массив строк матрицы (<code>p</code>)</p>

<ul>
<li>Освободить память из-под данных (адрес данных = адрес строки <code>0</code>);</li>
<li>Освободить память из-под массива указателей (<code>p</code>).</li>
</ul>

<table>
<colgroup>
<col>
<col>
</colgroup>

<thead>
</thead>

<tbody>
<tr>
	<td> <strong>Плюсы</strong></td>
	<td> <strong>Минусы</strong> </td>
</tr>
<tr>
	<td> <br>Относительная простота выделения и освобождения памяти.<br><br> </td>
	<td> <br>Отладчик использования памяти не может отследить выход за пределы строки. </td>
</tr>
<tr>
	<td>  <br>Возможность использовать как одномерный массив.<br><br>  </td>
	<td>   <br>Относительная сложность начальной инициализации.<br>   </td>
</tr>
<tr>
	<td>  <br>Перестановка строк через обмен указателей.<br><br>  </td>
	<td>                    </td>
</tr>
</tbody>
</table>

<h2 id="Объединениеподходов2.🔼top"><strong>Объединение подходов (2).</strong> <a href="#top">🔼</a></h2>

<figure>
<img src="/Users/dezodorant/Desktop/Скрины/Снимок%20экрана%202025-01-29%20в%2007.21.48.png" alt="">
<figcaption></figcaption>
</figure>

<p><strong>Алгоритм выделения памяти.</strong></p>

<p><strong>Вход</strong>:</p>

<p><code>n</code>, <code>m</code>.</p>

<p><strong>Выход</strong>:</p>

<p>Указатель на массив строк матрицы (<code>p</code>).</p>

<ol>
<li>Выделить память под массив указателей на строки и элементы матрицы (<code>p</code>);</li>
<li>Обработать ошибку выделения памяти;</li>
<li>В цикле по количеству строк <strong>матрицы</strong> (<code>0 &lt;= i &lt; n</code>):</li>
</ol>

<ul>
<li>Вычислить адрес <code>i</code>-ой строки матрицы (<code>q</code>);</li>
<li><code>p[i] = q</code>.</li>
</ul>

<table>
<colgroup>
<col>
<col>
</colgroup>

<thead>
</thead>

<tbody>
<tr>
	<td> <strong>Плюсы</strong></td>
	<td> <strong>Минусы</strong> </td>
</tr>
<tr>
	<td> <br>Перестановка строк через обмен указателей.<br><br> </td>
	<td> <br>Отладчик использования памяти не может отследить выход за пределы строки. </td>
</tr>
<tr>
	<td> <br>Возможность использовать как одномерный массив.<br><br> </td>
	<td>     <br>Сложность начальной инициализации.<br>     </td>
</tr>
<tr>
	<td> <br>Простота выделения и освобождения памяти.<br><br> </td>
	<td>                    </td>
</tr>
</tbody>
</table>

<p><strong>Общее сравнение:</strong></p>

<table>
<colgroup>
<col>
<col style="text-align:center;">
<col style="text-align:center;">
<col style="text-align:center;">
<col style="text-align:center;">
</colgroup>

<thead>
<tr>
	<th> <strong>Характеристика</strong>             </th>
	<th style="text-align:center;"> <strong>Одномерный массив</strong> </th>
	<th style="text-align:center;"> <strong>Массив указателей</strong> </th>
	<th style="text-align:center;"> <strong>Объединение (1)</strong> </th>
	<th style="text-align:center;"> <strong>Объединение (2)</strong> </th>
</tr>
</thead>

<tbody>
<tr>
	<td> Возможность использовать как одномерный массив.      </td>
	<td style="text-align:center;">  Есть.   </td>
	<td style="text-align:center;">  Нет.   </td>
	<td style="text-align:center;">  Есть.  </td>
	<td style="text-align:center;">  Есть .  </td>
</tr>
<tr>
	<td> Выделение и освобождение памяти.          </td>
	<td style="text-align:center;">  Просто.  </td>
	<td style="text-align:center;">  Сложно.  </td>
	<td style="text-align:center;"> Относительно просто. </td>
	<td style="text-align:center;">  Просто.  </td>
</tr>
<tr>
	<td> Начальная инициализация.            </td>
	<td style="text-align:center;">   –   </td>
	<td style="text-align:center;">   –   </td>
	<td style="text-align:center;"> Относительно сложно. </td>
	<td style="text-align:center;">  Сложно.  </td>
</tr>
<tr>
	<td> Отладчик использования памяти может отследить выход за пределы строк. </td>
	<td style="text-align:center;">  Нет.  </td>
	<td style="text-align:center;">  Да.  </td>
	<td style="text-align:center;">   Нет.  </td>
	<td style="text-align:center;">  Нет.  </td>
</tr>
<tr>
	<td> Перестановка строк через обмен указателей.       </td>
	<td style="text-align:center;">   –   </td>
	<td style="text-align:center;">  Да.  </td>
	<td style="text-align:center;">  Да.  </td>
	<td style="text-align:center;">  Да.  </td>
</tr>
</tbody>
</table>

<div style="page-break-after: always;"></div>

<h1 id="Чтениесложныхобъявлений.🔼top"><strong>Чтение сложных объявлений.</strong><a href="#top">🔼</a></h1>

<p><code>[]</code> - массив типа …</p>

<p><code>[N]</code> - массив из <strong>N</strong> элементов типа …</p>

<p><code>(type)</code> - функция, принимающая аргумент типа <em>type</em> и возвращающая …</p>

<p><code>*</code> - указатель на …</p>

<ol>
<li>Читать нужно изнутри наружу (т.е. с имени сущности). Или же: двигаемся вправо пока можем, иначе влево.</li>
<li>Отправная точка — идентификатор.</li>
<li>Нужно отдавать предпочтение <code>[]</code> и <code>()</code>, а не <code>*</code></li>
</ol>

<pre><code class="text hljs language-prolog" data-highlighted="yes">*name[] - массив типа, а не указатель на ...
*name() - функция, принимающая, а не указатель на ...
</code></pre>

<p><strong>Примеры</strong></p>

<pre><code class="с hljs language-apache" data-highlighted="yes"><span class="hljs-attribute">long</span> **foo[<span class="hljs-number">7</span>];
</code></pre>

<p>Массив из 7 элементов типа указатель на указатель на <code>long</code>.</p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">int</span> *(*x[<span class="hljs-number">10</span>])(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>); 
</code></pre>

<p>Массив из 10 элементов типа указатель на функцию, которая принимает два аргумента типа <code>int</code> и возвращает указатель на <code>int</code>.</p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">char</span> *(*(**foo[][<span class="hljs-number">8</span>])())[]; 
</code></pre>

<p>Массив типа массив из 8 элементов типа указатель на указатель на функцию, которая ничего не принимает и возвращает указатель на массив типа указатель на <code>char</code>.</p>

<p><strong>Семантические ограничения</strong></p>

<ul>
<li>Массив функций создать нельзя:</li>
</ul>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">int</span> a[<span class="hljs-number">10</span>](<span class="hljs-type">int</span>);
</code></pre>

<ul>
<li>Функция не может возвращать функцию:</li>
</ul>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">int</span> <span class="hljs-title function_">g</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;
</code></pre>

<ul>
<li>Функция не может вернуть массив:</li>
</ul>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>[];
</code></pre>

<ul>
<li>Для массива только левая лексема <code>[]</code> может быть пустой:</li>
</ul>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">int</span> a[][];
</code></pre>

<ul>
<li>Тип <code>void</code> ограниченный:</li>
</ul>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">void</span> x;
<span class="hljs-type">void</span> x[<span class="hljs-number">5</span>];
</code></pre>

<p><strong>Использование typedef.</strong></p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">int</span> *(*x[<span class="hljs-number">10</span>])(<span class="hljs-type">void</span>);

<span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> *<span class="hljs-title function_">func_t</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;
<span class="hljs-keyword">typedef</span> <span class="hljs-type">func_t</span> *func_ptr;
<span class="hljs-keyword">typedef</span> func_ptr func_ptr_arr[<span class="hljs-number">10</span>];

func_ptr_arr x;
</code></pre>

<div style="page-break-after: always;"></div>

<h1 id="Строкивдинамическойпамяти.Функцииposixирасширениеgnustrdupgetlinesprintf.🔼top"><strong>Строки в динамической памяти. Функции POSIX и расширение GNU (<code>strdup</code>, <code>getline</code>, <code>sprintf</code>).</strong><a href="#top">🔼</a></h1>

<p><code>strdup</code>, <code>strndup</code></p>

<p><code>strdup</code>, <code>strndup</code> — дублирование строки с ограничением по количеству байт.</p>

<p><strong>Прототипы:</strong></p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span>

<span class="hljs-type">char</span> *<span class="hljs-title function_">strdup</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span>;
<span class="hljs-type">char</span> *<span class="hljs-title function_">strndup</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s, <span class="hljs-type">size_t</span> size)</span>;
</code></pre>

<p><code>strdup</code> — возвращает указатель на новую строку, являющуюся дубликатом строки, на которую указывает <code>s</code>. Неудача создания новой строки — возврат <code>NULL</code>.</p>

<p><code>strndup</code> — аналогична работе <code>strdup</code>, выделяет память через <code>malloc</code>, но копирует не более <code>size + 1</code> байт, завершая строку <code>NUL</code>-символом.</p>

<ul>
<li><code>s &gt; size</code> — копируется только <code>size</code> байт.</li>
<li><code>s &lt; size</code> — копируется вся строка, включая <code>NUL</code>-символ.</li>
</ul>

<p>Новосозданная строка должна быть правильно завершена.</p>

<p><code>getline</code>.</p>

<p><code>getline</code> — считывание записи из потока.</p>

<p><strong>Прототип:</strong></p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-type">ssize_t</span> <span class="hljs-title function_">getline</span><span class="hljs-params">(<span class="hljs-type">char</span> **<span class="hljs-keyword">restrict</span> lineptr, 
<span class="hljs-type">size_t</span> *<span class="hljs-keyword">restrict</span> n,
FILE *<span class="hljs-keyword">restrict</span> stream)</span>;
</code></pre>

<p>Считывает строку из <code>stream</code> до симола <code>\n</code> или <code>EOF</code>.</p>

<p><code>*lineptr == NULL</code> или размер буфера недостаточен:</p>

<ul>
<li><code>malloc</code> или <code>realloc</code>;</li>
<li><code>*n</code> обновляется до нового размера;</li>
<li><code>*lineptr</code> обновляется, если объект переместился.</li>
</ul>

<p>Прочитанная строка сохраняется в <code>*lineptr</code>, включая <code>\n</code> (если встречен до <code>EOF</code>), и завершается <code>NUL</code>-символом.</p>

<ul>
<li>Возвращает количество записанных байт, включая <code>\n</code>, но без завершающего <code>NUL</code>-символа.</li>
<li>Достигнут <code>EOF</code> и не считано ни одного символа —устанавка флага <code>EOF</code>, функция возвращает <code>-1</code>.</li>
<li>В случае ошибки: Устанавливается флаг ошибки потока и функция возвращает <code>-1</code>.</li>
</ul>

<p><code>sprintf</code>, <code>snprintf</code>, <code>asprintf</code></p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">sprintf</span><span class="hljs-params">(<span class="hljs-type">char</span> *s, 
<span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span>;  <span class="hljs-comment">// ISO C90</span>

<span class="hljs-type">int</span> <span class="hljs-title function_">snprintf</span><span class="hljs-params">(<span class="hljs-type">char</span> *s, <span class="hljs-type">size_t</span> n, 
<span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span>;  <span class="hljs-comment">// C99</span>

<span class="hljs-type">int</span> <span class="hljs-title function_">asprintf</span><span class="hljs-params">(<span class="hljs-type">char</span> **s, 
<span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span>;  <span class="hljs-comment">// GNU</span>
</code></pre>

<p><code>sprintf</code> записывает отформатированную строку в <code>s</code> без проверки размера буфера.</p>

<p><code>snprintf</code> — аналогичен <code>sprintf</code>, но:</p>

<ul>
<li><code>n</code> указывает размер буфера <code>s</code>;</li>
<li><code>n == 0</code>— ничего не записывается, но возвращается длина строки, которая была бы записана;</li>
<li>Строка длиннее <code>n - 1</code> байт — лишние символы отбрасываются, а в конец записывается <code>NUL</code>-символ.</li>
</ul>

<p><code>asprintf</code> — аналогичен <code>sprintf</code>, но:</p>

<ul>
<li><code>malloc</code> выделяет буфер под строку.</li>
<li>Указатель <code>*s</code> обновляется, если <code>malloc</code> или <code>realloc</code> переместил объект.</li>
<li>Освобождение памяти выполняется через <code>free</code>.</li>
</ul>

<p><code>sprintf</code>, <code>snprintf</code>, <code>asprintf</code> записывают данные в перекрывающиеся области памяти — поведение неопределённое.</p>

<p>Форматная строка <code>format</code> содержит:</p>

<ul>
<li>Обычные символы (копируются в <code>s</code>);</li>
<li>Спецификаторы формата <code>%</code>, которые определяют выводимые аргументы.</li>
</ul>

<p><strong>Возврат:</strong></p>

<ul>
<li><code>sprintf</code> возвращает количество записанных байт, без учёта завершающего <code>NUL</code>-символа;</li>
<li><code>snprintf</code> возвращает количество байт, которое должно было быть записано, даже если буфер недостаточен;</li>
<li><code>asprintf</code> возвращает количество записанных байт или <code>-1</code> при ошибке выделения памяти;</li>
<li>При ошибке возвращается отрицательное значение.</li>
</ul>

<p><strong>Feature test macros.</strong></p>

<p><strong>Feature Test Macros (FTM)</strong> используются для включения или выключения определенных
функциональных возможностей или расширений в стандартной библиотеке.</p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-comment">// начиная с glibc 2.10 и новее</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> _POSIX_C_SOURCE 200809L</span>

<span class="hljs-comment">// в старых версиях glibc до 2.10</span>
<span class="hljs-meta"># <span class="hljs-keyword">define</span> _GNU_SOURCE</span>
</code></pre>

<div style="page-break-after: always;"></div>

<h1 id="Использованиеструктурсполями-указателями.🔼top"><strong>Использование структур с полями-указателями.</strong><a href="#top">🔼</a></h1>

<p>В Си определена операция присваивания для структурных переменных одного типа. Она фактически эквивалентна копированию области памяти, занимаемой одной переменной, в область памяти, занимаемую другой.</p>

<p><strong>Поверхностное копирование</strong> — копируется содержимое структурной переменной, но не копируется то, на что могут ссылать поля структуры.</p>

<p><strong>Глубокое копирование</strong> — создание копий объектов, на которые ссылаются поля структуры.</p>

<p>Рассмотрим пример:</p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">book_t</span>
{</span>
	<span class="hljs-type">char</span> *title;
	<span class="hljs-type">int</span> year;
};
</code></pre>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-keyword">struct</span> <span class="hljs-type">book_t</span> *<span class="hljs-title function_">book_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *title, 
<span class="hljs-type">int</span> year)</span>
{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">book_t</span> *<span class="hljs-title">pbook</span> =</span> 
    <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> <span class="hljs-type">book_t</span>));

    <span class="hljs-keyword">if</span> (pbook != <span class="hljs-literal">NULL</span>)
    {
        pbook-&gt;title = strdup(title);
        
        <span class="hljs-keyword">if</span> (pbook-&gt;title)
        {
            pbook-&gt;year = year;
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-built_in">free</span>(pbook);
            pbook = <span class="hljs-literal">NULL</span>;
        }
    }

    <span class="hljs-keyword">return</span> pbook;
}
</code></pre>

<p>Поверхностное копирование — вызов ошибки (двойное освобождение памяти):</p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">book_t</span> <span class="hljs-title">a</span> =</span> { <span class="hljs-number">0</span> }, b = { <span class="hljs-number">0</span> };

a.title = strdup(<span class="hljs-string">"Book a"</span>);
a.year = <span class="hljs-number">2000</span>;

b.title = strdup(<span class="hljs-string">"Book b"</span>);
b.year = <span class="hljs-number">2005</span>;

a = b;

<span class="hljs-built_in">free</span>(a.title);
<span class="hljs-built_in">free</span>(b.title); <span class="hljs-comment">// ERR</span>
</code></pre>

<p>До поверхностного и глубокого копирования:</p>

<figure>
<img src="/Users/dezodorant/Desktop/Скрины/Снимок%20экрана%202025-01-30%20в%2015.26.03.png" alt="">
<figcaption></figcaption>
</figure>

<p>После поверхностного копирования:</p>

<figure>
<img src="/Users/dezodorant/Desktop/Скрины/Снимок%20экрана%202025-01-30%20в%2015.27.21.png" alt="">
<figcaption></figcaption>
</figure>

<p>Пример глубокого копирования:</p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">int</span> <span class="hljs-title function_">book_copy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">book_t</span> *dst, <span class="hljs-type">const</span> 
<span class="hljs-keyword">struct</span> <span class="hljs-type">book_t</span> *src)</span>
{
	<span class="hljs-type">int</span> rc = <span class="hljs-number">0</span>;
    <span class="hljs-type">char</span> *temp = strdup(src-&gt;title);
    
    <span class="hljs-keyword">if</span> (temp == <span class="hljs-literal">NULL</span>)
    {
    		rc = <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">else</span>
    {
    		<span class="hljs-built_in">free</span>(dst-&gt;title);
    		dst-&gt;title = temp;
    		dst-&gt;year = src-&gt;year;
    }
    
    <span class="hljs-keyword">return</span> rc;
}

...

book_copy(&amp;b, &amp;a);

...

<span class="hljs-built_in">free</span>(a.title);
<span class="hljs-built_in">free</span>(b.title);
</code></pre>

<p>После глубокого копирования:</p>

<figure>
<img src="/Users/dezodorant/Desktop/Скрины/Снимок%20экрана%202025-01-30%20в%2015.26.03.png" alt="">
<figcaption></figcaption>
</figure>

<p><strong>Рекурсивное освобождение памяти.</strong></p>

<p>Для выделенной динамически структуры с полем-указателем, при освобождении памяти —
сначала надо освободить память из-под внутренних полей, потом из-под самой структуры.</p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">void</span> <span class="hljs-title function_">book_free</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">book_t</span> *pbook)</span>
{
    <span class="hljs-keyword">if</span> (pbook != <span class="hljs-literal">NULL</span>)
    {
        <span class="hljs-built_in">free</span>(pbook-&gt;title);
        <span class="hljs-built_in">free</span>(pbook);
    }
}
</code></pre>

<div style="page-break-after: always;"></div> 

<h1 id="Структурыпеременногоразмера.🔼top"><strong>Структуры переменного размера.</strong> <a href="#top">🔼</a></h1>

<p><strong>TLV</strong> (Type (или Tag) Length Value) — схема кодирования произвольных данных в некоторых телекоммуникационных протоколах.</p>

<ul>
<li><strong>Type</strong> – описание назначения данных;</li>
<li><strong>Length</strong> – размер данных (обычно в байтах);</li>
<li><strong>Value</strong> – данные.</li>
</ul>

<p>Первые два поля имеют фиксированный размер.</p>

<p><strong>TLV</strong> кодирование используется в:</p>

<ul>
<li>семействе протоколов TCP/IP;</li>
<li>спецификация PC/SC (smart cards);</li>
<li>ASN.1;</li>
<li>...</li>
</ul>

<p>Преимущества <strong>TLV</strong> кодирования:</p>

<ul>
<li>Простота разбора;</li>
<li>«Тройки» <strong>TLV</strong> c неизвестным типом (тегом) могут быть пропущены при разборе;</li>
<li>«Тройки» <strong>TLV</strong> могут размещаться в произвольном порядке;</li>
<li>«Тройки» <strong>TLV</strong> обычно кодируются двоично, что позволяет выполнять разбор быстрее и требует меньше объема по сравнению с кодированием, основанном на текстовом представлении.</li>
</ul>

<p><strong>Flexible array member (C99).</strong></p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">s</span>
{</span> 
	<span class="hljs-type">int</span> n;
	<span class="hljs-type">double</span> d[];
};
</code></pre>

<ul>
<li>Подобное поле должно быть последним;</li>
<li>Нельзя создать массив структур с таким полем;</li>
<li>Структура с таким полем не может использоваться как член в «середине» другой структуры;</li>
<li>Операция <code>sizeof</code> не учитывает размер этого поля (возможно, за исключением выравнивания);</li>
<li>Если в этом массиве нет элементов, то обращение к его элементам — неопределенное поведение.</li>
</ul>

<div style="page-break-after: always;"></div> 

<h1 id="Динамическирасширяемыймассив.🔼top"><strong>Динамически расширяемый массив.</strong> <a href="#top">🔼</a></h1>

<p><strong>Массив</strong> — последовательность элементов одного типа, расположенных в памяти друг за другом.</p>

<p><strong>Динамический массив</strong> — это массив, размер которого задаётся в момент выполнения программы, а не на этапе компиляции.</p>

<p><strong>Динамически расширяемый массив</strong> — структура данных, представляющая собой увеличивающийся блок памяти, который хранит элементы одного типа.</p>

<p><strong>Отличие от динамического массива.</strong></p>

<p><strong>Особенности реализации.</strong></p>

<ul>
<li>Поскольку адрес массива может измениться, программа должна обращаться к элементами массива по индексам;
Удвоение размера массива при каждом вызове <code>realloc</code> сохраняет средние «ожидаемые» затраты на копирование элемента;</li>
<li>Благодаря маленькому начальному размеру массива, программа сразу же «проверяет» код, реализующий выделение памяти.</li>
</ul>

<p><strong>Почему память надо выделять крупными блоками?</strong></p>

<ul>
<li>Для уменьшение потерь при распределении памяти изменение размера должно происходить относительно крупными блоками;</li>
<li>Для простоты реализации указатель на выделенную память должен храниться вместе со всей информацией, необходимой для управления динамическим массивом.</li>
</ul>

<p><strong>Достоинства и недостатки массивов</strong></p>

<p><strong>Плюсы:</strong></p>

<ul>
<li>Простота использования;</li>
<li>Константное время доступа к любому элементу;</li>
<li>Не тратят лишние ресурсы;</li>
<li>Хорошо сочетаются с двоичным поиском.</li>
</ul>

<p><strong>Минусы:</strong></p>

<ul>
<li>Хранение меняющегося набора значений.</li>
</ul>

<div style="page-break-after: always;"></div>

<h1 id="Линейныйодносвязныйсписок.🔼top"><strong>Линейный односвязный список.</strong> <a href="#top">🔼</a></h1>

<p><strong>Массив</strong> — последовательность элементов одного типа, расположенных в памяти друг за другом.</p>

<p><strong>Преимущества и недостатки массива</strong> объясняются стратегией выделения памяти: память под все элементы выделяется в одном блоке.</p>

<p><strong>Плюсы:</strong></p>

<ul>
<li>Минимальные накладные расходы;</li>
<li>Константное время доступа к элементу.</li>
</ul>

<p><strong>Минусы:</strong></p>

<ul>
<li>Хранение меняющегося набора значений.</li>
</ul>

<p><strong>Связанный список</strong> – это набор элементов, причем каждый из них — часть узла, который также содержит ссылку на следующий и/или предыдущий узел списка.</p>

<figure>
<img src="/Users/dezodorant/Desktop/Скрины/Снимок%20экрана%202025-02-19%20в%2002.08.57.png" alt="">
<figcaption></figcaption>
</figure>

<p><strong>Узел</strong> – единица хранения данных, несущая в себе ссылки на связанные с ней узлы.</p>

<p><strong>Структура узла:</strong></p>

<ul>
<li>Информационная часть (данные);</li>
<li>Ссылочная часть (связь с другими узлами).</li>
</ul>

<p><strong>Отличие списков от массивов.</strong></p>

<ul>
<li>Связный список, как и массив, хранит набор элементов одного типа, но память под каждый элемент выделяется отдельно и лишь тогда, когда это нужно;</li>
<li>Основное преимущество связных списков перед массивами — возможность эффективного изменения расположения элементов;</li>
<li>За эту гибкость приходится жертвовать скоростью доступа к произвольному элементу списка, т.к. единственный способ получения элемента состоит в отслеживании связей от начала списка.</li>
</ul>

<p><strong>Линейный одноcвязный список</strong> – структура данных, состоящая из узлов, каждый из которых ссылается на следующий узел списка.</p>

<figure>
<img src="/Users/dezodorant/Desktop/Скрины/Снимок%20экрана%202025-02-19%20в%2002.08.57.png" alt="">
<figcaption></figcaption>
</figure>

<p><strong>Основные свойства.</strong></p>

<ul>
<li>Узел, на который нет указателя, является первым элементом списка. Обычно этот узел называется <strong>головой списка</strong>;</li>
<li>Последний элемент списка никуда не ссылается (ссылается на <code>NULL</code>). Обычно этот узел называется <strong>хвостом списка</strong>.</li>
</ul>

<p><strong>Свойства одноcвязного списка.</strong></p>

<ul>
<li>Передвигаться можно только в сторону конца списка;</li>
<li>Узнать адрес предыдущего элемента, опираясь только на содержимое текущего узла, нельзя.</li>
</ul>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node_t</span>
{</span>
    <span class="hljs-type">int</span> data;
    <span class="hljs-type">node_t</span> *next;
} <span class="hljs-type">node_t</span>;
</code></pre>

<h2 id="Добавлениевначало.🔼top"><strong>Добавление в начало.</strong> <a href="#top">🔼</a></h2>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">int</span> <span class="hljs-title function_">push_front</span><span class="hljs-params">(node **head, <span class="hljs-type">int</span> value)</span>
{
    <span class="hljs-type">int</span> push_state = ERR_MEM;
    node *new_node = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));

    <span class="hljs-keyword">if</span> (new_node != <span class="hljs-literal">NULL</span>)
    {
        new_node-&gt;data = value;
        new_node-&gt;next = *head;
        *head = new_node;
        push_state = OK;
    }

    <span class="hljs-keyword">return</span> push_state;
}
</code></pre>

<h2 id="Добавлениевконец.🔼top"><strong>Добавление в конец.</strong> <a href="#top">🔼</a></h2>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">int</span> <span class="hljs-title function_">push_back</span><span class="hljs-params">(node **head, <span class="hljs-type">int</span> value)</span>
{
    <span class="hljs-type">int</span> push_state = ERR_MEM;
    node *new_node = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));
    node *temp = *head;

    <span class="hljs-keyword">if</span> (new_node != <span class="hljs-literal">NULL</span>)
    {
        new_node-&gt;data = value;
        new_node-&gt;next = <span class="hljs-literal">NULL</span>;

        <span class="hljs-keyword">if</span> (*head == <span class="hljs-literal">NULL</span>)
        {
            *head = new_node;
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-keyword">while</span> (temp-&gt;next != <span class="hljs-literal">NULL</span>)
            {
                temp = temp-&gt;next;
            }
            temp-&gt;next = new_node;
        }

        push_state = OK;
    }

    <span class="hljs-keyword">return</span> push_state;
}
</code></pre>

<h2 id="Удалениесписка.🔼top"><strong>Удаление списка.</strong> <a href="#top">🔼</a></h2>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">void</span> <span class="hljs-title function_">free_list</span><span class="hljs-params">(node **head)</span>
{
    node *temp;

    <span class="hljs-keyword">while</span> (*head != <span class="hljs-literal">NULL</span>)
    {
        temp = *head;
        *head = (*head)-&gt;next;
        <span class="hljs-built_in">free</span>(temp);
    }
}
</code></pre>

<h2 id="Освобождениесписка.🔼top"><strong>Освобождение списка.</strong> <a href="#top">🔼</a></h2>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">int</span> <span class="hljs-title function_">remove_if</span><span class="hljs-params">(node **head, <span class="hljs-type">int</span> value)</span>
{
    <span class="hljs-type">int</span> remove_state = ERR_EMPTY;
    node *temp = *head;
    node *prev = <span class="hljs-literal">NULL</span>;

    <span class="hljs-keyword">while</span> (temp != <span class="hljs-literal">NULL</span> &amp;&amp; temp-&gt;data != value)
    {
        prev = temp;
        temp = temp-&gt;next;
    }

    <span class="hljs-keyword">if</span> (temp != <span class="hljs-literal">NULL</span>)
    {
        <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">NULL</span>)
        {
            *head = temp-&gt;next;
        }
        <span class="hljs-keyword">else</span>
        {
            prev-&gt;next = temp-&gt;next;
        }

        <span class="hljs-built_in">free</span>(temp);
        remove_state = OK;
    }

    <span class="hljs-keyword">return</span> remove_state;
}
</code></pre>

<h2 id="Вставкапередузлом.🔼top"><strong>Вставка перед узлом.</strong> <a href="#top">🔼</a></h2>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">int</span> <span class="hljs-title function_">insert_before</span><span class="hljs-params">(node **head, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> value)</span>
{
    <span class="hljs-type">int</span> insert_state = ERR_EMPTY;
    node *new_node = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));
    node *temp = *head;
    node *prev = <span class="hljs-literal">NULL</span>;

    <span class="hljs-keyword">if</span> (new_node != <span class="hljs-literal">NULL</span>)
    {
        <span class="hljs-keyword">while</span> (temp != <span class="hljs-literal">NULL</span> &amp;&amp; temp-&gt;data != target)
        {
            prev = temp;
            temp = temp-&gt;next;
        }

        <span class="hljs-keyword">if</span> (temp != <span class="hljs-literal">NULL</span>)
        {
            new_node-&gt;data = value;
            new_node-&gt;next = temp;

            <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">NULL</span>)
            {
                *head = new_node;
            }
            <span class="hljs-keyword">else</span>
            {
                prev-&gt;next = new_node;
            }

            insert_state = OK;
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-built_in">free</span>(new_node);
        }
    }
    <span class="hljs-keyword">else</span>
    {
        insert_state = ERR_MEM;
    }

    <span class="hljs-keyword">return</span> insert_state;
}
</code></pre>

<h2 id="Вставкапослеузла.🔼top"><strong>Вставка после узла.</strong> <a href="#top">🔼</a></h2>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">int</span> <span class="hljs-title function_">insert_after</span><span class="hljs-params">(node **head, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> value)</span>
{
    <span class="hljs-type">int</span> insert_state = ERR_EMPTY;
    node *new_node = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));
    node *temp = *head;

    <span class="hljs-keyword">if</span> (new_node != <span class="hljs-literal">NULL</span>)
    {
        <span class="hljs-keyword">while</span> (temp != <span class="hljs-literal">NULL</span> &amp;&amp; temp-&gt;data != target)
        {
            temp = temp-&gt;next;
        }

        <span class="hljs-keyword">if</span> (temp != <span class="hljs-literal">NULL</span>)
        {
            new_node-&gt;data = value;
            new_node-&gt;next = temp-&gt;next;
            temp-&gt;next = new_node;
            insert_state = OK;
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-built_in">free</span>(new_node);
        }
    }
    <span class="hljs-keyword">else</span>
    {
        insert_state = ERR_MEM;
    }

    <span class="hljs-keyword">return</span> insert_state;
}
</code></pre>

<h2 id="Универсальныйобход.🔼top"><strong>Универсальный обход.</strong> <a href="#top">🔼</a></h2>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">void</span> <span class="hljs-title function_">traverse_list</span><span class="hljs-params">(node *head, <span class="hljs-type">void</span> (*func)(node *))</span>
{
    <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">NULL</span>)
    {
        func(head);
        head = head-&gt;next;
    }
}
</code></pre>

<div style="page-break-after: always;"></div> 

<h1 id="Двоичноедеревопоиска.🔼top"><strong>Двоичное дерево поиска.</strong> <a href="#top">🔼</a></h1>

<p><strong>Дерево</strong> — связный ациклический граф.</p>

<p><strong>Двоичное дерево поиска</strong> — это дерево, все вершины которого упорядочены, каждая вершина имеет не более двух потомков (назовём их левым и правым), и все вершины, кроме корня, имеют родителя.</p>

<p>У двоичного дерева значение левого потомка <strong>меньше</strong> значения родителя, а значение правого потомка <strong>больше</strong> значения родителя для каждого узла дерева. Это свойство позволяет реализовать эффективный поиск.</p>

<h2 id="Узелдерева.🔼top"><strong>Узел дерева.</strong> <a href="#top">🔼</a></h2>

<p><strong>Узел дерева</strong> обычно состоит из двух частей:</p>

<ul>
<li><strong>Информационная часть</strong> (данные).</li>
<li><strong>Ссылочная часть</strong> (связь с другими узлами).</li>
</ul>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tree_node</span>
{</span>
    <span class="hljs-type">int</span> data;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tree_node</span> *<span class="hljs-title">left</span>;</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tree_node</span> *<span class="hljs-title">right</span>;</span>
} tree_node;
</code></pre>

<p>В некоторых реализациях узел может содержать указатель на родителя, но в стандартном двоичном дереве поиска <strong>указатель на родителя не является обязательным</strong>.</p>

<h2 id="Сравнениесдеревом.🔼top"><strong>Сравнение с деревом.</strong> <a href="#top">🔼</a></h2>

<p><strong>Обычное двоичное дерево.</strong></p>

<ul>
<li>Каждый узел может иметь <strong>не более двух потомков</strong>;</li>
<li>Нет ограничений на порядок значений;</li>
<li>В худшем случае сложность операций <strong>O(n)</strong>.</li>
</ul>

<p><strong>Двоичное дерево поиска (BST).</strong></p>

<ul>
<li>Левое поддерево содержит только узлы с <strong>меньшими значениями</strong>;</li>
<li>Правое поддерево содержит только узлы с <strong>большими значениями</strong>;</li>
<li>Средняя сложность операций <strong>O(log n)</strong>.</li>
</ul>

<p>Двоичное дерево поиска <strong>компромиссное решение</strong> между обычным деревом и сбалансированными структурами. Оно обеспечивает <strong>быстрый поиск</strong> при условии сбалансированности.</p>

<p><strong>DOT</strong> – язык описания графов.</p>

<ul>
<li>Граф, описанный на языке DOT, обычно представляет собой текстовый файл с расширением <code>.gv</code> в понятном для человека и обрабатывающей программы формате;</li>
<li>В графическом виде графы, описанные на языке DOT, представляются с помощью специальных программ, например Graphviz.</li>
</ul>

<p><strong>Описание дерева на DOT.</strong></p>

<pre><code class="dot hljs language-rust" data-highlighted="yes"><span class="hljs-comment">// Описание дерева на DOT</span>
digraph test_tree 
{
    f <span class="hljs-punctuation">-&gt;</span> b;
    f <span class="hljs-punctuation">-&gt;</span> k;
    b <span class="hljs-punctuation">-&gt;</span> a;
    b <span class="hljs-punctuation">-&gt;</span> d;
    k <span class="hljs-punctuation">-&gt;</span> g;
    k <span class="hljs-punctuation">-&gt;</span> l;
}
</code></pre>

<h2 id="Рекурсивныйпоиск.🔼top"><strong>Рекурсивный поиск.</strong> <a href="#top">🔼</a></h2>

<pre><code class="c hljs language-c" data-highlighted="yes">tree_node *<span class="hljs-title function_">search_recursive</span><span class="hljs-params">(tree_node *root, <span class="hljs-type">int</span> value)</span>
{
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span> || root-&gt;data == value)
    {
        <span class="hljs-keyword">return</span> root;
    }
    
    <span class="hljs-keyword">if</span> (value &lt; root-&gt;data)
    {
        <span class="hljs-keyword">return</span> search_recursive(root-&gt;left, value);
    }
    
    <span class="hljs-keyword">return</span> search_recursive(root-&gt;right, value);
}
</code></pre>

<h2 id="Итеративныйпоиск.🔼top"><strong>Итеративный поиск.</strong> <a href="#top">🔼</a></h2>

<pre><code class="c hljs language-c" data-highlighted="yes">tree_node *<span class="hljs-title function_">search_iterative</span><span class="hljs-params">(tree_node *root, <span class="hljs-type">int</span> value)</span>
{
    <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;data != value)
    {
        <span class="hljs-keyword">if</span> (value &lt; root-&gt;data)
        {
            root = root-&gt;left;
        }
        <span class="hljs-keyword">else</span>
        {
            root = root-&gt;right;
        }
    }

    <span class="hljs-keyword">return</span> root;
}
</code></pre>

<h2 id="Добавлениеузла.🔼top"><strong>Добавление узла.</strong> <a href="#top">🔼</a></h2>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">int</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(tree_node **root, <span class="hljs-type">int</span> value)</span>
{
    <span class="hljs-type">int</span> insert_state = ERR_MEM;

    <span class="hljs-keyword">if</span> (*root == <span class="hljs-literal">NULL</span>)
    {
        *root = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(tree_node));
        <span class="hljs-keyword">if</span> (*root != <span class="hljs-literal">NULL</span>)
        {
            (*root)-&gt;data = value;
            (*root)-&gt;left = <span class="hljs-literal">NULL</span>;
            (*root)-&gt;right = <span class="hljs-literal">NULL</span>;
            insert_state = OK;
        }
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value &lt; (*root)-&gt;data)
    {
        insert_state = insert(&amp;(*root)-&gt;left, value);
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value &gt; (*root)-&gt;data)
    {
        insert_state = insert(&amp;(*root)-&gt;right, value);
    }

    <span class="hljs-keyword">return</span> insert_state;
}
</code></pre>

<h2 id="Универсальныйобход.🔼top"><strong>Универсальный обход.</strong> <a href="#top">🔼</a></h2>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">void</span> <span class="hljs-title function_">traverse_tree</span><span class="hljs-params">(tree_node *root, <span class="hljs-type">void</span> (*func)(tree_node *))</span>
{
    <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>)
    {
        traverse_tree(root-&gt;left, func);
        func(root);
        traverse_tree(root-&gt;right, func);
    }
}
</code></pre>

<h2 id="Рекурсивноеудаление.🔼top"><strong>Рекурсивное удаление.</strong> <a href="#top">🔼</a></h2>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">int</span> <span class="hljs-title function_">delete_recursive</span><span class="hljs-params">(node **root, <span class="hljs-type">int</span> value)</span>
{
    <span class="hljs-keyword">if</span> (*root == <span class="hljs-literal">NULL</span>)
    {
        <span class="hljs-keyword">return</span> ERR_EMPTY;
    }

    <span class="hljs-keyword">if</span> (value &lt; (*root)-&gt;data)
    {
        <span class="hljs-keyword">return</span> delete_recursive(&amp;(*root)-&gt;left, value);
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value &gt; (*root)-&gt;data)
    {
        <span class="hljs-keyword">return</span> delete_recursive(&amp;(*root)-&gt;right, value);
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-keyword">if</span> ((*root)-&gt;right == <span class="hljs-literal">NULL</span>)
        {
            node *temp = *root;
            *root = (*root)-&gt;left;
            <span class="hljs-built_in">free</span>(temp);
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((*root)-&gt;left == <span class="hljs-literal">NULL</span>)
        {
            node *temp = *root;
            *root = (*root)-&gt;right;
            <span class="hljs-built_in">free</span>(temp);
        }
        <span class="hljs-keyword">else</span>
        {
            node *temp = find_min((*root)-&gt;right);
            (*root)-&gt;data = temp-&gt;data;
            <span class="hljs-keyword">return</span> delete_recursive(&amp;(*root)-&gt;right, temp-&gt;data);
        }
    }

    <span class="hljs-keyword">return</span> OK;
}
</code></pre>

<h2 id="Итеративноеудаление.🔼top"><strong>Итеративное удаление.</strong> <a href="#top">🔼</a></h2>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">int</span> <span class="hljs-title function_">delete_iterative</span><span class="hljs-params">(node **root, <span class="hljs-type">int</span> value)</span> 
{
    <span class="hljs-type">int</span> rc = OK;
    node *parent = <span class="hljs-literal">NULL</span>;
    node *current = *root;

    <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">NULL</span> &amp;&amp; current-&gt;data != value) 
    {
        parent = current;
        <span class="hljs-keyword">if</span> (value &lt; current-&gt;data) 
        {
            current = current-&gt;left;
        } 
        <span class="hljs-keyword">else</span> 
        {
            current = current-&gt;right;
        }
    }

    <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">NULL</span>) 
    {
        rc = ERR_EMPTY;
    } 
    <span class="hljs-keyword">else</span> 
    {
        <span class="hljs-keyword">if</span> (current-&gt;right == <span class="hljs-literal">NULL</span>) 
        {
            <span class="hljs-keyword">if</span> (parent == <span class="hljs-literal">NULL</span>) 
            {
                *root = current-&gt;left;
            } 
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parent-&gt;left == current) 
            {
                parent-&gt;left = current-&gt;left;
            } 
            <span class="hljs-keyword">else</span> 
            {
                parent-&gt;right = current-&gt;left;
            }
        } 
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current-&gt;left == <span class="hljs-literal">NULL</span>) 
        {
            <span class="hljs-keyword">if</span> (parent == <span class="hljs-literal">NULL</span>) 
            {
                *root = current-&gt;right;
            } 
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parent-&gt;left == current) 
            {
                parent-&gt;left = current-&gt;right;
            } 
            <span class="hljs-keyword">else</span> 
            {
                parent-&gt;right = current-&gt;right;
            }
        } 
        <span class="hljs-keyword">else</span> 
        {
            node *min_parent = current;
            node *min_node = current-&gt;right;

            <span class="hljs-keyword">while</span> (min_node-&gt;left != <span class="hljs-literal">NULL</span>) 
            {
                min_parent = min_node;
                min_node = min_node-&gt;left;
            }

            current-&gt;data = min_node-&gt;data;
            <span class="hljs-keyword">if</span> (min_parent-&gt;left == min_node) 
            {
                min_parent-&gt;left = min_node-&gt;right;
            } 
            <span class="hljs-keyword">else</span> 
            {
                min_parent-&gt;right = min_node-&gt;right;
            }
            current = min_node;
        }
        <span class="hljs-built_in">free</span>(current);
    }

    <span class="hljs-keyword">return</span> rc;
}
</code></pre>

<div style="page-break-after: always;"></div>

<h1 id="КучавСи.Алгоритмыработыmallocfree.Выравнивание.🔼top"><strong>Куча в Си. Алгоритмы работы <code>malloc</code>, <code>free</code>. Выравнивание.</strong> <a href="#top">🔼</a></h1>

<h2 id="КучавСи.🔼top"><strong>Куча в Си.</strong> <a href="#top">🔼</a></h2>

<p>Области, в которых программа может размещать данные</p>

<ol>
<li><strong>Cегменты данных</strong> — константы и глобальные переменные.</li>
<li><strong>Cтек</strong> — для вызова функций и создания локальных переменных.</li>
<li><strong>Куча</strong> — для динамического выделения памяти.</li>
</ol>

<p><strong>Куча</strong> — пул свободной памяти.</p>

<p>Возможно, термин произошёл как противопоставление термину <strong>стека</strong>, т. к. в стеке элементы расположены один над другим, а в куче определённого порядка в расположении элементов нет.</p>

<p><strong>Особенности использования динамической памяти:</strong></p>

<ul>
<li>Для хранения данных используется куча.</li>
<li>Создать переменную в куче нельзя, но можно выделить память под неё.</li>
</ul>

<p><strong>Преимущества:</strong></p>

<ul>
<li>Размер данных известен на этапе выполнения программы, а не на этапе компиляции.</li>
<li>Размер данных в куче на несколько порядков больше размера данных на стеке.</li>
<li>Время жизни данных в куче никак не связано со временем жизни того блока, в котором выделялась память под эти данные (можно выделить память в одной функции, а очистить в другой).</li>
</ul>

<p><strong>Недостатки:</strong></p>

<ul>
<li>Ручное управление временем жизни (сами выделили память — сами освободили)</li>
</ul>

<p>Свойства области, выделенной <code>malloc</code>:</p>

<ul>
<li>Возвращает область, размер которой не меньше запрашиваемого размера.</li>
<li>Указатель, возвращенный <code>malloc</code>, указывает на выделенную область, т.е. область, в которую программа может писать и из которой может читать данные.</li>
<li>Ни один другой вызов этой функции не может повторно возвратить одну и ту же область до её освобождения.</li>
</ul>

<p>Для моделирования области памяти под кучу используем одномерный массив:</p>

<figure>
<img src="/Users/dezodorant/Desktop/Скрины/Снимок%20экрана%202025-02-18%20в%2013.24.19.png" alt="">
<figcaption></figcaption>
</figure>

<p>Программист выделил 100 байт:</p>

<figure>
<img src="/Users/dezodorant/Desktop/Скрины/Снимок%20экрана%202025-02-18%20в%2013.25.32.png" alt="">
<figcaption></figcaption>
</figure>

<p>Чтобы выделить следующую область важно представлять:</p>

<ul>
<li>Какие области в нашей кучи заняты, а какие свободные.</li>
<li>Где эти области расположены.</li>
<li>Размер этих областей.</li>
</ul>

<p>Метаинформацию располагают в начале самой области.</p>

<p>Выделяем 100 байт + размер метаинформации.</p>

<figure>
<img src="/Users/dezodorant/Desktop/Скрины/Снимок%20экрана%202025-02-18%20в%2013.30.52.png" alt="">
<figcaption></figcaption>
</figure>

<p><strong>Фрагментация</strong> - чередование участков памяти при последовательных запросах на выделение и освобождение памяти. «Занятые» участки чередуются со «свободными» —
однако последние могут быть недостаточно большими для того, чтобы сохранить в них нужное данное.</p>

<p><strong>Дефрагментация</strong> в куче выполняется для устранения фрагментации и улучшения производительности выделения и освобождения блоков памяти. В процессе дефрагментации происходит перераспределение блоков памяти таким образом, чтобы создать большие непрерывные свободные блоки и уменьшить фрагментацию.</p>

<h2 id="Алгоритмыработыmalloc.🔼top"><strong>Алгоритмы работы <code>malloc</code>.</strong> <a href="#top">🔼</a></h2>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-comment">// Структура для хранения информации о блоках памяти</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">block_t</span>
{</span>
	<span class="hljs-type">size_t</span> size;        <span class="hljs-comment">// Размер блока памяти</span>
	<span class="hljs-type">int</span> <span class="hljs-built_in">free</span>;           <span class="hljs-comment">// Флаг: 1 — свободен, 0 — занят</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">block_t</span> *<span class="hljs-title">next</span>;</span> <span class="hljs-comment">// Указатель на следующий блок</span>
};

<span class="hljs-meta">#<span class="hljs-keyword">define</span> MY_HEAP_SIZE 1000000 <span class="hljs-comment">// Размер "кучи"</span></span>

<span class="hljs-comment">// Буфер, который эмулирует оперативную память</span>
<span class="hljs-type">static</span> <span class="hljs-type">char</span> my_heap[MY_HEAP_SIZE];

<span class="hljs-comment">// Список блоков памяти (изначально указывает на начало "кучи")</span>
<span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">block_t</span> *<span class="hljs-title">free_list</span> =</span> (<span class="hljs-keyword">struct</span> <span class="hljs-type">block_t</span>*) my_heap;

<span class="hljs-comment">// Инициализация списка блоков памяти</span>
<span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
	free_list-&gt;size = <span class="hljs-keyword">sizeof</span>(my_heap) - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> <span class="hljs-type">block_t</span>); <span class="hljs-comment">// Весь доступный размер</span>
	free_list-&gt;<span class="hljs-built_in">free</span> = <span class="hljs-number">1</span>; <span class="hljs-comment">// Помечаем как свободный</span>
	free_list-&gt;next = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// Следующего блока пока нет</span>
}

<span class="hljs-comment">// Разбиение блока на два, если он больше запрашиваемого размера</span>
<span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">split_block</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">block_t</span> *block, <span class="hljs-type">size_t</span> size)</span>
{
	<span class="hljs-type">size_t</span> rest = block-&gt;size - size;
	
	<span class="hljs-comment">// Если оставшаяся часть после разбиения достаточна для нового блока</span>
	<span class="hljs-keyword">if</span> (rest &gt; <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> <span class="hljs-type">block_t</span>))
	{
		<span class="hljs-comment">// Создаём новый блок после выделенного участка</span>
		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">block_t</span> *<span class="hljs-title">new</span> =</span> (<span class="hljs-type">void</span>*)((<span class="hljs-type">char</span>*)block + size + <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> <span class="hljs-type">block_t</span>));
		new-&gt;size = block-&gt;size - size - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> <span class="hljs-type">block_t</span>);
		new-&gt;<span class="hljs-built_in">free</span> = <span class="hljs-number">1</span>;
		new-&gt;next = block-&gt;next;
		
		<span class="hljs-comment">// Обновляем текущий блок</span>
		block-&gt;size = size;
		block-&gt;<span class="hljs-built_in">free</span> = <span class="hljs-number">0</span>;
		block-&gt;next = new;
	}
	<span class="hljs-keyword">else</span>
	{
		<span class="hljs-comment">// Если место недостаточно для нового блока — просто помечаем блок как занятый</span>
		block-&gt;<span class="hljs-built_in">free</span> = <span class="hljs-number">0</span>;
	}
}

<span class="hljs-comment">// Выделение памяти (аналог malloc)</span>
<span class="hljs-type">void</span> *<span class="hljs-title function_">my_malloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span>
{
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">block_t</span> *<span class="hljs-title">cur</span>;</span>
	<span class="hljs-type">void</span> *result;

	<span class="hljs-comment">// Проверяем, инициализирован ли список блоков</span>
	<span class="hljs-keyword">if</span> (!free_list-&gt;size)
		init();

	<span class="hljs-comment">// Ищем свободный блок достаточного размера</span>
	cur = free_list;
	<span class="hljs-keyword">while</span> (cur &amp;&amp; (cur-&gt;<span class="hljs-built_in">free</span> == <span class="hljs-number">0</span> || cur-&gt;size &lt; size))
		cur = cur-&gt;next;

	<span class="hljs-comment">// Если подходящего блока нет — ошибка</span>
	<span class="hljs-keyword">if</span> (!cur)
	{
		result = <span class="hljs-literal">NULL</span>;
	}
	<span class="hljs-comment">// Если найденный блок точно по размеру — просто помечаем его как занятый</span>
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur-&gt;size == size)
	{
		cur-&gt;<span class="hljs-built_in">free</span> = <span class="hljs-number">0</span>;
		result = (<span class="hljs-type">void</span>*) (++cur);
	}
	<span class="hljs-comment">// Если найденный блок больше, чем требуется — разбиваем его</span>
	<span class="hljs-keyword">else</span>
	{
		split_block(cur, size);
		result = (<span class="hljs-type">void</span>*) (++cur);
	}

	<span class="hljs-keyword">return</span> result;
}
</code></pre>

<h2 id="Алгоритмыработыfree.🔼top"><strong>Алгоритмы работы <code>free</code>.</strong> <a href="#top">🔼</a></h2>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-comment">// Функция слияния соседних свободных блоков памяти</span>
<span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">merge_blocks</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">block_t</span> *<span class="hljs-title">cur</span> =</span> free_list;
    <span class="hljs-comment">// Проходим по списку блоков</span>
    <span class="hljs-keyword">while</span> (cur &amp;&amp; cur-&gt;next != <span class="hljs-literal">NULL</span>)
    {
        <span class="hljs-comment">// Если текущий и следующий блок свободны, объединяем их</span>
        <span class="hljs-keyword">if</span> (cur-&gt;<span class="hljs-built_in">free</span> &amp;&amp; cur-&gt;next-&gt;<span class="hljs-built_in">free</span>)
        {
            <span class="hljs-comment">// Увеличиваем размер текущего блока, объединяя с соседним</span>
            cur-&gt;size += cur-&gt;next-&gt;size + <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> <span class="hljs-type">block_t</span>);
            <span class="hljs-comment">// Переподключаем следующий блок</span>
            cur-&gt;next = cur-&gt;next-&gt;next;
        }
        <span class="hljs-keyword">else</span>
        {
            cur = cur-&gt;next; <span class="hljs-comment">// Переходим к следующему блоку</span>
        }
    }
}

<span class="hljs-comment">// Функция освобождения памяти</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">my_free</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr)</span>
{
    <span class="hljs-comment">// Проверка, что указатель лежит в пределах выделенной области "кучи"</span>
    <span class="hljs-keyword">if</span> (my_heap &lt;= (<span class="hljs-type">char</span>*) ptr &amp;&amp; (<span class="hljs-type">char</span>*) ptr &lt; my_heap + <span class="hljs-keyword">sizeof</span>(my_heap))
    {
        <span class="hljs-comment">// Переходим к блоку, который перед выделенной памятью</span>
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">block_t</span> *<span class="hljs-title">cur</span> =</span> ptr;
        --cur; <span class="hljs-comment">// Получаем ссылку на блок, к которому принадлежит память</span>

        cur-&gt;<span class="hljs-built_in">free</span> = <span class="hljs-number">1</span>; <span class="hljs-comment">// Помечаем блок как свободный</span>
        merge_blocks(); <span class="hljs-comment">// Объединяем соседние свободные блоки, если они есть</span>
    }
    <span class="hljs-keyword">else</span>
        <span class="hljs-comment">// Если указатель некорректен, выводим ошибку</span>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Wrong pointer\n"</span>);
}

</code></pre>

<h2 id="Выравнивание.🔼top"><strong>Выравнивание.</strong> <a href="#top">🔼</a></h2>

<p><strong>Проблемы выравнивания выделенной области памяти.</strong></p>

<p>Для хранения произвольных объектов блок должен быть правильно выровнен. В каждой системе есть самый «требовательный» тип данных — если элемент этого типа можно поместить по некоторому адресу, то любые другие элементы тоже можно поместить туда.</p>

<p>Чтобы определить самый требовательный тип, используется специальный тип данных:</p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">align_t</span>;
</code></pre>

<p>Для обеспечения правильного выравнивания можно использовать объединение <code>union</code>, где один из элементов гарантирует корректное выравнивание:</p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">block_t</span> 
{</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> 
    {</span>
        <span class="hljs-type">size_t</span> size;
        <span class="hljs-type">int</span> <span class="hljs-built_in">free</span>;
        <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">block_t</span> *<span class="hljs-title">next</span>;</span>
    } block;
    
    <span class="hljs-type">align_t</span> x;
};
</code></pre>

<p>Так как все блоки памяти должны быть одинаково выровнены, размер выделяемой памяти кратен размеру метаинформации. Запрашиваемый размер области обычно округляется до значения, кратного размеру заголовка.</p>

<pre><code class="c hljs language-c" data-highlighted="yes">n_blocks = (size - <span class="hljs-number">1</span> + <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">union</span> <span class="hljs-type">block_t</span>)) / <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">union</span> <span class="hljs-type">block_t</span>);
alloc_size = n_blocks * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">union</span> <span class="hljs-type">block_t</span>);
</code></pre>

<p><strong>Выравнивание</strong> — это размещение значений в памяти по адресам, кратным некоторому целому числу, большему единицы.</p>

<p>Причина, по которой существует такое понятие, заключается в том, что процессорам проще оперировать выровненными значениями.</p>

<p><strong>Естественное выравнивание</strong> — это выравнивание значений встроенных типов (как правило, поддерживаемых процессором непосредственно) по адресам, кратным размеру этого типа. Например, 4-байтные целые размещаются по адресам, кратным четырём (0, 4, 8, 12 и так далее), а 8-байтные значения типа <code>double</code> размещаются по адресам, кратным восьми (0, 8, 16, 24 и так далее).</p>

<div style="page-break-after: always;"></div>

<h1 id="variablelengtharray.Функцияalloca.🔼top"><strong>Variable length array. Функция <code>alloca</code>.</strong> <a href="#top">🔼</a></h1>

<h2 id="variablelengtharray.🔼top"><strong>Variable length array.</strong> <a href="#top">🔼</a></h2>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);
<span class="hljs-type">int</span> a[n];
</code></pre>

<ul>
<li>Длина такого массива вычисляется во время выполнения программы, а не во время компиляции;</li>
<li>Память под элементы массива выделяется на стеке;</li>
<li>Массивы переменного размера нельзя инициализировать при определении;</li>
<li>Массивы переменной длины могут быть многомерными;</li>
<li>Адресная арифметика справедлива для массивов переменной длины;</li>
<li>Массивы переменной длины облегчают описание заголовков функций, которые обрабатывают массивы.</li>
</ul>

<h2 id="Функцияalloca.🔼top"><strong>Функция<code>alloca</code>.</strong> <a href="#top">🔼</a></h2>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;alloca.h&gt;</span></span>

<span class="hljs-type">void</span> *<span class="hljs-title function_">alloca</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span>;
</code></pre>

<ul>
<li>Функция <code>alloca</code> выделяет область памяти, размером <code>size</code> байт, на стеке.</li>
<li>Функция возвращает указатель на начало выделенной области. Эта область автоматически освобождается, когда функция, которая вызвала <code>alloca</code>, возвращает управления вызывающей стороне.</li>
<li>Если выделение вызывает переполнение стека, поведение программы не определено.</li>
</ul>

<p><strong>Плюсы :</strong></p>

<ul>
<li>Выделение происходит быстро;</li>
<li>Выделенная область освобождается автоматически.</li>
</ul>

<p><strong>Минусы :</strong></p>

<ul>
<li>Функция нестандартная;</li>
<li>Серьёзные ограничения по размеру области.</li>
</ul>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-comment">// VLA, когда тело цикла закончится, массив </span>
<span class="hljs-comment">// разрушится (т.к. переменная вышла </span>
<span class="hljs-comment">// из области видимости)</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span>
{
	...
	<span class="hljs-keyword">while</span> (b)
	{
		<span class="hljs-type">char</span> tmp[size];
		...
	}
}

<span class="hljs-comment">// alloca, массив выделится, но память останется</span>
<span class="hljs-comment">// до конца работы функции и </span>
<span class="hljs-comment">// легко получить переполнение стека</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span>
{
	...
	<span class="hljs-keyword">while</span> (b)
	{
		<span class="hljs-type">char</span> *tmp = alloca(size);
		...
	}
}
</code></pre>

<p><strong>Пример использования VLA:</strong></p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> 
{
    <span class="hljs-type">int</span> n;
    
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n) == <span class="hljs-number">1</span> &amp;&amp; n &gt; <span class="hljs-number">0</span>) 
    {
        <span class="hljs-type">int</span> a[n];  <span class="hljs-comment">// VLA</span>

        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-type">size_t</span>)n; i++) 
        {
            a[i] = i;
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-type">size_t</span>)n; i++) 
        {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, a[i]);
        }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p><strong>Плюсы VLA:</strong></p>

<ul>
<li>Простота в использовании, соответствие стандарту C99.</li>
<li>Автоматическое освобождение памяти при выходе из области видимости.</li>
</ul>

<p><strong>Минусы VLA:</strong></p>

<ul>
<li>Не поддерживаются в C90 и могут не поддерживаться в некоторых компиляторах C11+.</li>
<li>Переполнение стека при выделении больших массивов.</li>
</ul>

<p><strong>Пример использования <code>alloca</code>:</strong></p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;alloca.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> 
{
    <span class="hljs-type">int</span> n;
    <span class="hljs-type">int</span> *a = <span class="hljs-literal">NULL</span>;

    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n) == <span class="hljs-number">1</span> &amp;&amp; n &gt; <span class="hljs-number">0</span>) 
    {
        a = alloca(n * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));

        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-type">size_t</span>)n; i++) 
        {
            a[i] = i;
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-type">size_t</span>)n; i++) 
        {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, a[i]);
        }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>

<p><strong>Плюсы <code>alloca</code>:</strong></p>

<ul>
<li>Быстрое выделение памяти.</li>
<li>Память освобождается автоматически.</li>
</ul>

<p><strong>Минусы <code>alloca</code>:</strong></p>

<ul>
<li>Функция нестандартная, отсутствует в ISO C.</li>
<li>Серьезные ограничения по размеру области, cуществует риск переполнения стека.</li>
<li>Память остается до завершения функции, даже если выделение происходит в цикле.</li>
</ul>

<table>
<colgroup>
<col>
<col>
<col>
</colgroup>

<thead>
<tr>
	<th> Критерий.       </th>
	<th> <code>alloca.</code>          </th>
	<th> <code>VLA</code>.           </th>
</tr>
</thead>

<tbody>
<tr>
	<td> <strong>Место выделения памяти.</strong>   </td>
	<td> Стек.           </td>
	<td> Стек.           </td>
</tr>
<tr>
	<td> <strong>Освобождение памяти.</strong>    </td>
	<td> Автоматически при выходе из функции.   </td>
	<td> Автоматически при выходе из области видимости. </td>
</tr>
<tr>
	<td> <strong>Размер выделенной памяти.</strong>  </td>
	<td> Определяется во время выполнения программы. </td>
	<td> Определяется во время выполнения программы. </td>
</tr>
<tr>
	<td> <strong>Переполнение стека.</strong>    </td>
	<td> Поведение неопределено при переполнении.  </td>
	<td> Переполнение возможно при больших массивах. </td>
</tr>
<tr>
	<td> <strong>Поведение в цикле.</strong>    </td>
	<td> Память сохраняется до конца работы функции. </td>
	<td> Память разрушается при выходе из области видимости. </td>
</tr>
<tr>
	<td> <strong>Ошибка при неправильном выделении.</strong> </td>
	<td> Приводит к неопределенному поведению.  </td>
	<td> Обычно вызывает переполнение стека, если массив слишком большой. </td>
</tr>
</tbody>
</table>

<div style="page-break-after: always;"></div>

<h1 id="Функцииспеременнымчисломпараметров.🔼top"><strong>Функции с переменным числом параметров.</strong> <a href="#top">🔼</a></h1>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(...)</span>;
</code></pre>

<ul>
<li>Во время компиляции компилятору не известны ни количество параметров, ни их типы.</li>
<li>Во время компиляции компилятор не выполняет никаких проверок.</li>
</ul>

<p>НО список параметров функции с переменным числом аргументов совсем пустым быть не может.</p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> k, ...)</span>;
</code></pre>

<p>Напишем функцию, вычисляющую среднее арифметическое своих аргументов.
Проблемы:</p>

<ol>
<li>Как определить адрес параметров в стеке?</li>
<li>Как перебирать параметры?</li>
<li>Как закончить перебор?</li>
</ol>

<p><strong>Наивная реализация. Причина некорректной работы.</strong></p>

<p>По <strong>cdecl</strong> параметры в функцию передаются справа налево, т.е. можно получить адрес параметра так:</p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">double</span> <span class="hljs-title function_">avg</span><span class="hljs-params">(<span class="hljs-type">int</span> n, ...)</span> 
{
    <span class="hljs-type">double</span> result = <span class="hljs-number">0.0</span>;

    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) 
    {
        <span class="hljs-type">int</span> *p_i = &amp;n;
        <span class="hljs-type">double</span> *p_d = (<span class="hljs-type">double</span> *)(p_i + <span class="hljs-number">1</span>);
        <span class="hljs-type">double</span> sum = <span class="hljs-number">0.0</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; n; i++, p_d++) 
        {
            sum += *p_d;
        }

        result = sum / n;
    }

    <span class="hljs-keyword">return</span> result;
}
</code></pre>

<p>Однако работать это не будет, так как аргументы могут передаваться с <strong>выравниванием</strong>.</p>

<p><strong>Стандартный способ работы с параметрами функций с переменным числом параметров - <code>stdarg.h</code></strong></p>

<p><code>va_list</code>: Тип для хранения информации о переменных аргументах.
<code>void va_start(va_list argptr, last_param)</code>: Инициализирует <code>va_list</code> для обхода аргументов.
<code>type va_arg(va_list argptr, type)</code>: Извлекает следующий аргумент заданного типа.
<code>void va_end(va_list argptr)</code>: Завершает обработку переменных аргументов.</p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdarg.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-type">double</span> <span class="hljs-title function_">avg</span><span class="hljs-params">(<span class="hljs-type">int</span> n, ...)</span> 
{
    <span class="hljs-type">double</span> result = <span class="hljs-number">0.0</span>;
    
    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) 
    {
        va_list vl;
        va_start(vl, n);

        <span class="hljs-type">double</span> sum = <span class="hljs-number">0.0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) 
        {
            <span class="hljs-type">double</span> num = va_arg(vl, <span class="hljs-type">double</span>);
            sum += num;
        }

        va_end(vl);
        result = sum / n;
    }

    <span class="hljs-keyword">return</span> result;
}
</code></pre>

<div style="page-break-after: always;"></div>

<h1 id="Препроцессор.Общиепонятия.Директивыinclude.Простыемакросы.Предопределённыемакросы.Макросыспараметрами.Директивыусловнойкомпиляции.Директивыerrorpragma.Операцияи.🔼top"><strong>Препроцессор. Общие понятия. Директивы <code>include</code>. Простые макросы. Предопределённые макросы. Макросы с параметрами. Директивы условной компиляции. Директивы <code>error</code>, <code>pragma</code>. Операция <code>#</code> и <code>##</code>.</strong> <a href="#top">🔼</a></h1>

<h2 id="Препроцессор.Общиепонятия.🔼top"><strong>Препроцессор. Общие понятия.</strong> <a href="#top">🔼</a></h2>

<p><strong>Препроцессор</strong> — программа, подготавливающая код программы к компиляции. При запуске программы, препроцессор просматривает код сверху вниз, файл за файлом, в поиске директив.</p>

<p>Задачи препроцессора:</p>

<ul>
<li>Удаление комментариев;</li>
<li>Выполнение директив.</li>
</ul>

<p><strong>Директивы</strong> — это специальные команды, которые начинаются с символа <code>#</code> и заканчиваются
на символе <code>\n</code>. Любое количество пробельных символов может разделять лексемы в директиве.</p>

<p><strong>Типы директив:</strong></p>

<ul>
<li>Макроопределения (<code>#define</code>, <code>#undef</code>);</li>
<li>Директива включения файлов (<code>#include</code>);</li>
<li>Директивы условной компиляции (<code>#if</code>, <code>#ifdef</code>, <code>#ifndef</code>, <code>#endif</code>, ...)</li>
<li>остальные директивы (редко используются)[<code>#pragma</code>, <code>#error</code>, ...].</li>
</ul>

<h2 id="Простыемакросы.🔼top"><strong>Простые макросы.</strong> <a href="#top">🔼</a></h2>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-meta">#<span class="hljs-keyword">define</span> идентификатор список-замены</span>
</code></pre>

<p>Использование:</p>

<ul>
<li>Имена для числовых, символьных и строковых констант:</li>
</ul>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI 3.14</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> NEWLINE <span class="hljs-string">'\n'</span></span>
</code></pre>

<ul>
<li>Незначительное изменение синтаксиса языка:</li>
</ul>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BEGIN {</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> END }</span>
</code></pre>

<ul>
<li>Переименование типов:</li>
</ul>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BOOL int</span>
</code></pre>

<ul>
<li>Предотвращение повторного включения заголовочных файлов (<code>include guard</code>):</li>
</ul>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> DEFINES_H</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> DEFINES_H</span>

...

<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre>

<p><strong>Общие свойства макросов:</strong></p>

<ul>
<li>Список-замены макроса может содержать другие макросы;</li>
<li>Препроцессор заменяет только целые лексемы, не их части;</li>
<li>Определение макроса остается «известным» до конца файла, в котором этот макрос объявляется;</li>
<li>Макрос не может быть объявлен дважды, если эти объявления не тождественны;</li>
<li>Макрос может быть «разопределён» с помощью директивы <code>#undef</code>.</li>
</ul>

<h2 id="Директивыусловнойкомпиляции.🔼top"><strong>Директивы условной компиляции.</strong> <a href="#top">🔼</a></h2>

<p>Директива <code>if</code> в языке программирования позволяет проверить условие и выполнить определенный блок кода, если условие выполняется.</p>

<p>Директива <code>ifdef</code> (или <code>ifndef</code>) также проверяет условие, но в зависимости от того, создано ли макроопределение с таким именем. Если оно создано (или не создано), то выполняется определенный блок кода (эквивалентно <code>#if defined()</code>).</p>

<p><code>#if</code> vs <code>#ifdef</code>.</p>

<table>
<colgroup>
<col>
<col>
<col>
</colgroup>

<thead>
<tr>
	<th> <strong>Критерий</strong>    </th>
	<th> <strong><code>#if</code></strong>         </th>
	<th> <strong><code>#ifdef</code></strong>        </th>
</tr>
</thead>

<tbody>
<tr>
	<td> <strong>Назначение</strong>   </td>
	<td> Проверяет <strong>целочисленное константное выражение</strong>. </td>
	<td> Проверяет <strong>существование макроса</strong> (<code>#define</code>). </td>
</tr>
<tr>
	<td> <strong>Обрабатываемый тип данных</strong> </td>
	<td> Любое <strong>целочисленное выражение</strong>, включая <code>defined(идентификатор)</code>. </td>
	<td> Только <strong>наличие макроса</strong>, без проверки значения. </td>
</tr>
<tr>
	<td> <strong>Допустимые операции</strong> </td>
	<td> Арифметические, логические, побитовые. </td>
	<td> Операции <strong>не поддерживаются</strong>. </td>
</tr>
<tr>
	<td> <strong>Использование <code>defined()</code></strong> </td>
	<td> Требует <strong>явного</strong> <code>defined(идентификатор)</code>, если проверяется макрос. </td>
	<td> Использует имя макроса <strong>непосредственно</strong>, без <code>defined()</code>. </td>
</tr>
<tr>
	<td> <strong>Обработка неопределённых макросов</strong> </td>
	<td> Если макрос <strong>не определён</strong>, он интерпретируется как <code>0</code>. </td>
	<td> Если макрос <strong>не определён</strong>, условие считается <code>false</code>. </td>
</tr>
<tr>
	<td> <strong>Проверка значения макроса</strong> </td>
	<td> Да, можно проверять <strong>значение</strong> (<code>#if VERSION &gt; 2</code>). </td>
	<td> Нет, проверяется только <strong>наличие</strong> макроса. </td>
</tr>
<tr>
	<td> <strong>Возможность вложенности</strong> </td>
	<td> Поддерживается. </td>
	<td> Поддерживается. </td>
</tr>
<tr>
	<td> <strong>Совместимость с <code>#else</code>, <code>#elif</code></strong> </td>
	<td> Поддерживается. </td>
	<td> Поддерживается. </td>
</tr>
<tr>
	<td> <strong>Эквивалентность</strong> </td>
	<td> <code>#if defined(ИДЕНТИФИКАТОР)</code> <strong>эквивалентно</strong> <code>#ifdef ИДЕНТИФИКАТОР</code>. </td>
	<td> <code>#ifdef ИДЕНТИФИКАТОР</code> <strong>эквивалентно</strong> <code>#if defined(ИДЕНТИФИКАТОР)</code>. </td>
</tr>
</tbody>
</table>

<h2 id="Макросыспараметрами.🔼top"><strong>Макросы с параметрами.</strong> <a href="#top">🔼</a></h2>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-meta">#<span class="hljs-keyword">define</span> идентификатор(x1, x2, ..., xn) список-замены</span>
</code></pre>

<p>– Не должно быть пробела между именем макроса и <code>(</code>.
– Список параметров может быть пустым.</p>

<p>Препроцессор просто заменяет макросы на их определения до компиляции​:</p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span>

<span class="hljs-type">int</span> x = MAX(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);  <span class="hljs-comment">// Преобразуется в</span>
<span class="hljs-comment">// ((10) &gt; (20) ? (10) : (20))</span>
</code></pre>

<p><strong>Макросы с параметрами vs функции:</strong></p>

<p><strong>Преимущества:</strong></p>

<ul>
<li>Программа может работать немного быстрее;</li>
<li>Макросы «универсальны».</li>
</ul>

<p><strong>Недостатки:</strong></p>

<ul>
<li>Скомпилированный код становится больше
<code>n = MAX(i,MAX(j, k)));</code> ;</li>
<li>Типы аргументов не проверяются;</li>
<li>Нельзя объявить указатель на макрос;</li>
<li>Макрос может вычислять аргументы несколько
раз <code>n = MAX(i++, j);</code>.</li>
</ul>

<p><strong>Макросы с переменным числом параметров:</strong></p>

<p>Используется условная компиляция с помощью <code>NDEBUG</code>:</p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> NDEBUG</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> DBG_PRINT(s, ...) printf(s, __VA_ARGS__)</span>
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> DBG_PRINT(s, ...) ((void) O)</span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre>

<p><strong>Скобки в макросах.</strong></p>

<ul>
<li>Если список-замены содержит операции, он должен быть заключен в скобки;</li>
<li>Если у макроса есть параметры, они должны быть заключены в скобки в списке-замены.</li>
</ul>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TWO_PI 2 * 3.14</span>
f = <span class="hljs-number">360.0</span> / TWO_PI;
<span class="hljs-comment">// f = 360.0 / 2 * 3.14;</span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> SCALE(x) (x * 10)</span>
j = SCALE(i + <span class="hljs-number">1</span>);
<span class="hljs-comment">// j = (i + 1 * 10);</span>
</code></pre>

<p><strong>Создание длинных макросов.</strong>
Часто используется <code>do-while</code> для возможности поставить <code>;</code> в конец макроса:</p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ECHO(s) \ </span>
<span class="hljs-keyword">do</span>              \ 
{               \ 
	gets(s);    \ 
	<span class="hljs-built_in">puts</span>(s);    \ 
}               \ 
<span class="hljs-keyword">while</span>(<span class="hljs-number">0</span>)        \ 
</code></pre>

<p>Оператор <code>,</code>:</p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ECHO(s) (gets(s), puts(s))</span>
</code></pre>

<p>Обертка в блок:</p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ECHO(s) {gets(s); puts(s);}</span>
</code></pre>

<h2 id="Предопределенныемакросы.🔼top"><strong>Предопределенные макросы.</strong> <a href="#top">🔼</a></h2>

<p>Эти идентификаторы нельзя переопределять или отменять директивой <code>undef</code>.</p>

<pre><code class="txt hljs language-erlang" data-highlighted="yes">- __LINE__ — номер текущей строки <span class="hljs-params">(десятичная константа)</span>;
- __FILE__ — имя компилируемого файла;
- __DATE__ — дата компиляции;
- __TIME__ — время компиляции;
- и др...
</code></pre>

<h2 id="Операциии.🔼top"><strong>Операции <code>#</code> и <code>##</code>.</strong> <a href="#top">🔼</a></h2>

<ul>
<li>Операция <code>#</code> конвертирует аргумент макроса в строковый литерал:</li>
</ul>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-comment">// скобки вокруг параметра не нужны</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> PRINT_INT(n) printf(#n <span class="hljs-string">" = %d\n"</span>, (n))</span>

...
PRINT_INT(i / j);
</code></pre>

<ul>
<li>Операция <code>##</code> объединяет две лексемы в одну:</li>
</ul>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONCAT(a, b) a##b</span>

...
<span class="hljs-type">int</span> var1 = <span class="hljs-number">42</span>;
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Value of var1: %d\n"</span>, CONCAT(var, <span class="hljs-number">1</span>)); 
<span class="hljs-comment">// Превращается в var1</span>
</code></pre>

<p><strong>Шаги обработки макроса с параметрами</strong></p>

<ul>
<li>Аргументы подставляются в список замены уже «раскрытыми», если к ним не применяются операции <code>#</code> или <code>##</code>.</li>
<li>После того, как все аргументы были «раскрыты» или выполнены операции <code>#</code> или <code>##</code>, результат просматривается препроцессором еще раз. Если результат работы препроцессора содержит имя исходного макроса, оно не заменяется.</li>
</ul>

<h2 id="error.🔼top"><strong><code>#error</code>.</strong> <a href="#top">🔼</a></h2>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(OS_WIN)</span>
...
<span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(OS_LIN)</span>
...
<span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(OS_MAC)</span>
...
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">error</span> Unsupported OS!</span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre>

<h2 id="pragma.🔼top"><strong><code>#pragma</code>.</strong> <a href="#top">🔼</a></h2>

<p>Директива <code>#pragma</code> позволяет добиться от компилятора специфичного поведения.</p>

<p>Часто используемые команды:</p>

<ul>
<li><code>pragma once</code>;</li>
<li>Выравнивание (упаковка структурных переменных <code>pragma pack</code>);</li>
<li>Прочее... (отключение/включение ошибок компилятора, запрет на использование функции и др.).</li>
</ul>

<div style="page-break-after: always;"></div> 

<h1 id="Встраиваемыефункции.🔼top"><strong>Встраиваемые функции.</strong> <a href="#top">🔼</a></h1>

<p><code>inline</code> — указывает компилятору на возможность замены вызова функции её телом (вставка кода функции на место вызова).</p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title function_">average</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span>
{
	<span class="hljs-keyword">return</span> (a + b) / <span class="hljs-number">2</span>;
}
</code></pre>

<p>В С99 <code>inline</code>-реализация не предоставляет и не запрещает реализацию со внешней линковкой. <code>inline</code> означает, что определение функции предоставляется только для подстановки и где-то в программе должно быть другое такое же определение этой же функции.</p>

<p>Ошибка при компоновке, если <code>add</code> не определена как <code>static</code> и не имеет внешнего определения:</p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>
{
    <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
    <span class="hljs-type">int</span> result = add(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>);
    <span class="hljs-keyword">return</span> result;
}
</code></pre>

<p><strong>Способы исправления:</strong>
Использование <code>static</code>:</p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>
{
<span class="hljs-keyword">return</span> a + b;
}
</code></pre>

<ul>
<li>Такая функция будет доступна только внутри текущего файла.</li>
</ul>

<p>Использование <code>extern inline</code>:</p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;
</code></pre>

<ul>
<li>Означает, что реализация находится в другом файле.</li>
</ul>

<p>Добавление ещё одного не-<code>inline</code> определения (обычно в файле реализации <code>.c</code>):</p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>
{
	<span class="hljs-keyword">return</span> a + b;
}
</code></pre>

<ul>
<li>Такой подход нужен, чтобы компоновщик мог связать вызовы этой функции.</li>
</ul>

<p><code>inline</code> был введен в С99 с целью оптимизации производительности за счет накладных
расходов на вызов функции. До этого программисты часто пользовались макросами для решения похожих задач, но макросы имеют недостатки (отсутствие контроля типов,
непредсказуемое поведение при использовании сложных выражений, сложность отладки).
<code>inline</code> — это безопасная альтернатива макросам.</p>

<h1 id="Библиотеки.🔼top"><strong>Библиотеки.</strong> <a href="#top">🔼</a></h1>

<h2 id="Библиотеки."><strong>Библиотеки.</strong></h2>

<p><strong>Библиотека</strong> — набор специальным образом оформленных объектных файлов.</p>

<p><strong>Библиотека</strong> включает в себя:</p>

<ul>
<li>Заголовочный файл;</li>
<li>Откомпилированный файл самой библиотеки (ниже поясним).</li>
</ul>

<p><strong>Причины:</strong></p>

<ul>
<li>Бибилиотеки редко меняются — нет причин каждый раз перекомпилировать.</li>
<li>Двоичный код предотвращает доступ к исходному коду.</li>
</ul>

<p>Библиотеки есть <strong>статичные</strong> и <strong>динамические</strong>.</p>

<h2 id="Статическиебиблиотеки.🔼top"><strong>Статические библиотеки.</strong> <a href="#top">🔼</a></h2>

<p><strong>Статичная</strong> библиотека связывается с программой в момент компоновки и код библиотеки помещается в исполняемый файл.</p>

<p><strong>Плюсы:</strong></p>

<ul>
<li>Исполняемый файл включает в себя всё необходимое;</li>
<li>Нет проблем с использованием не той версии библиотеки.</li>
</ul>

<p><strong>Минусы:</strong></p>

<ul>
<li>Размер;</li>
<li>Обновляется библиотека — пересобирается программа.</li>
</ul>

<p><strong>Сборка библиотеки:</strong></p>

<p>– Компиляция:</p>

<p><code>gcc -std=c99 -Wall -Werror -c arr_lib.c</code></p>

<p>– Упаковка (с заменой объектного файла на новый):</p>

<p><code>ar cr libarr.a arr_lib.o</code></p>

<p>– Индексирование (необязательно):</p>

<p><code>ranlib libarr.a</code></p>

<p><strong>Сборка приложения</strong></p>

<pre><code class="bash hljs language-nginx" data-highlighted="yes"><span class="hljs-attribute">gcc</span> -std=c99 -Wall -W<span class="hljs-literal">error</span> main.c -o app.exe libarr.a

<span class="hljs-comment"># gcc -std=c99 -Wall -Werror main.c -o app.exe -L. -larr</span>
<span class="hljs-comment"># -L - в какой директории осуществить поиск библиотеки</span>
<span class="hljs-comment"># -l [arr] - поиска библиотеки lib[arr].a</span>
</code></pre>

<p><strong>Граф зависимостей.</strong></p>

<figure>
<img src="/Users/dezodorant/Desktop/Скрины/Снимок%20экрана%202025-02-01%20в%2016.09.18.png" alt="">
<figcaption></figcaption>
</figure>

<table>
<colgroup>
<col>
<col>
<col>
</colgroup>

<thead>
<tr>
	<th> <strong>Критерий.</strong> </th>
	<th> <strong>Статические библиотеки.</strong> </th>
	<th> <strong>Динамические библиотеки.</strong> </th>
</tr>
</thead>

<tbody>
<tr>
	<td> <strong>Связывание.</strong> </td>
	<td> В момент компоновки. </td>
	<td> В момент выполнения. </td>
</tr>
<tr>
	<td> <strong>Размер исполняемого файла.</strong> </td>
	<td> Увеличивается. </td>
	<td> Остается небольшим. </td>
</tr>
<tr>
	<td> <strong>Обновление библиотеки.</strong> </td>
	<td> Требуется перекомпиляция программы. </td>
	<td> Можно обновлять без перекомпиляции. </td>
</tr>
<tr>
	<td> <strong>Совместное использование.</strong> </td>
	<td> Используется только в одном исполняемом файле. </td>
	<td> Может использоваться несколькими программами. </td>
</tr>
<tr>
	<td> <strong>Зависимости.</strong> </td>
	<td> Все необходимое содержится в исполняемом файле. </td>
	<td> Требуется наличие библиотеки в системе. </td>
</tr>
</tbody>
</table>

<h2 id="Динамическиебиблиотеки.🔼top"><strong>Динамические библиотеки.</strong> <a href="#top">🔼</a></h2>

<p><strong>Динамические</strong> библиотеки загружаются в приложение во время выполнения и код библиотеки не помещается в исполняемый файл.</p>

<p><strong>Плюсы:</strong></p>

<ul>
<li>Несколько программ могут разделять одну библиотеку;</li>
<li>Меньший размер приложения (по сравнению со статичной);</li>
<li>Модернизация библиотеки не требует перекомпиляции программы;</li>
<li>Могут использоваться программы на разных языках.</li>
</ul>

<p><strong>Минусы:</strong></p>

<ul>
<li>Библиотека должна быть на компьютере;</li>
<li>Версионность библиотек.</li>
</ul>

<p><strong>Способы использования динамических библиотек:</strong></p>

<ul>
<li><strong>Динамическая компоновка</strong> — часть функций по загрузке библиотеки и поиску в ней тех функций, которые нужны приложению, перекладываются на компоновщика.</li>
<li><strong>Динамическая загрузка</strong>— сами загружаем библиотеку, сами ищем нужные функции в библиотеке и сами завершаем использование библиотеки при помощи интерфейса ОС.</li>
</ul>

<h2 id="Динамическаякомпоновка.🔼top"><strong>Динамическая компоновка.</strong> <a href="#top">🔼</a></h2>

<p><strong>Сборка библиотеки</strong></p>

<ul>
<li>Компиляция:
<code>gcc -std=c99 -Wall -Werror -fPIC -c arr_lib.c</code>;</li>
<li>Компоновка:
<code>gcc -o libarr.so -shared arr_lib.o</code>.</li>
</ul>

<p><strong>Сборка приложения</strong></p>

<pre><code class="bash hljs language-nginx" data-highlighted="yes"><span class="hljs-attribute">gcc</span> -std=c99 -Wall -W<span class="hljs-literal">error</span> main.c -L. -larr -o app.exe

<span class="hljs-comment"># библиотека может быть не найдена операционной системой</span>
<span class="hljs-comment"># во время запуска</span>
<span class="hljs-comment"># LD_LIBRARY_PATH=$LD_LIBRARY_PATH:. /app.exe</span>

<span class="hljs-comment"># во время динамической компоновки</span>
<span class="hljs-comment"># gcc -std=c99 -Wall -Werror main.c -L. -larr -o app.exe -Wl,-rpath=.</span>
</code></pre>

<p><strong>Граф зависимостей:</strong></p>

<figure>
<img src="/Users/dezodorant/Desktop/Скрины/Снимок%20экрана%202025-02-01%20в%2016.21.09.png" alt="">
<figcaption></figcaption>
</figure>

<h2 id="Динамическаязагрузка.🔼top"><strong>Динамическая загрузка.</strong> <a href="#top">🔼</a></h2>

<p><strong>Сборка библиотеки</strong></p>

<ul>
<li>Компиляция:
<code>gcc -std=c99 -Wall -Werror -fPIC -c arr_lib.c</code>;</li>
<li>Компоновка:
<code>gcc -o libarr.so -shared arr_lib.o</code>.</li>
</ul>

<p><strong>Сборка приложения.</strong></p>

<pre><code class="bash hljs language-nginx" data-highlighted="yes"><span class="hljs-attribute">gcc</span> -std=c99 -Wall -W<span class="hljs-literal">error</span> main.c -ldl -o app.exe
</code></pre>

<p><strong>Граф зависимостей:</strong></p>

<figure>
<img src="/Users/dezodorant/Desktop/Скрины/Снимок%20экрана%202025-02-01%20в%2016.23.51.png" alt="">
<figcaption></figcaption>
</figure>

<p><code>void *dlopen(const char *file, int mode);</code> — загружает динамическую библиотеку и возвращает указатель на неё.</p>

<p><code>mode</code> – флаги управления загрузкой. Основные значения:</p>

<ul>
<li><code>RTLD_LAZY</code> – разрешает отложенную загрузку символов (функции подгружаются при первом вызове).</li>
<li><code>RTLD_NOW</code> – загружает все символы сразу (может быть полезно для отлова ошибок).</li>
<li><code>RTLD_GLOBAL</code> – делает символы библиотеки доступными для других загружаемых библиотек.</li>
<li><code>RTLD_LOCAL</code> – загруженные символы доступны только внутри данной библиотеки.</li>
</ul>

<p><code>void *dlsym(void *restrict handle, const char *restrict name);</code> — извлекает адрес функции или переменной из загруженной библиотеки.</p>

<p><code>int dlclose(void *handle);</code> — освобождает загруженную библиотеку.</p>

<h2 id="Порядоккомпоновкибиблиотеквlinux.🔼top"><strong>Порядок компоновки библиотек в <strong>Linux</strong>.</strong> <a href="#top">🔼</a></h2>

<p>В процессе компоновки играет роль порядок перечисленных объектных файлов и библиотек. Компоновщик однопроходный. Для правильного
распределения зависимостей существует 3 подхода:</p>

<ol>
<li>Запись библиотек с помощью префиксного обхода дерева зависимостей.</li>
<li>Использование ключа <code>-Wl,-\( … -Wl,\)</code>. Компоновщик сам разберётся.</li>
<li>Перечислить все файлы по нескольку раз.</li>
</ol>

<h2 id="Видимостьфункцийвlinuxиwindows.🔼top"><strong>Видимость функций в <strong>Linux</strong> и <strong>Windows</strong>.</strong> <a href="#top">🔼</a></h2>

<p>В <strong>Linux</strong> все функции динамической библиотеки без класса памяти <code>static</code> выгружаются в программу. В <strong>Windows</strong> — наоборот. Функции по умолчанию не доступны из библиотеки независимо от класса памяти.</p>

<p>Чтобы отправить функцию на экспорт из библиотеки в <strong>Windows</strong> используется <code>__declspec(dllexport)</code> в заголовке функции. Также явно указывается соглашение
о вызове (<code>__cdecl</code>). В самой программе нужно дополнительно разместить прототипы с <code>__declspec(dllimport)</code> и <code>__cdecl</code>.</p>

<p>Чтобы управлять видимостью в <strong>Linux</strong>, можно использовать следующую конструкцию.</p>

<ul>
<li><code>__attribute__((visibility("default")))</code> — глобальная область видимости для всех</li>
<li>функций.</li>
<li><code>__attribute__((visibility("hidden")))</code> — сокрытие отдельных функций.</li>
</ul>

<h2 id="Позиционныйизависимыйкод.gotиplt.🔼top"><strong>Позиционный и зависимый код. <strong>GOT</strong> и <strong>PLT</strong>.</strong> <a href="#top">🔼</a></h2>

<p><strong>PIC</strong> — код, независящий от своего расположения.
Используется в динамических библиотеках.</p>

<p><strong>PLT</strong> — таблица, перенаправляющая вызовы позиционно-независимого кода к абсолютным адресам.</p>

<p><strong>GOT</strong> — таблица, содержащая абсолютные адреса всех статических данных программы.</p>

<p>Переменная <strong>LD_PRELOAD</strong> позволяет загрузить выбранную библиотеку первее остальных. Она позволяет избежать прохода вызова через PLT.</p>

<h2 id="Подходыкреализациифункцийкоторымтребуетсясоздатьбуфердинамически.🔼top"><strong>Подходы к реализации функций, которым требуется создать буфер динамически.</strong> <a href="#top">🔼</a></h2>

<p>При использовании динамической памяти в динамических библиотеках существует 2 подхода:</p>

<ol>
<li>Вызывающая сторона выделяет и освобождает память.</li>
<li>Библиотека предоставляет функции выделения и освобождения памяти.</li>
</ol>

<h2 id="Приложениенаpython.Использованиемодуляctypesнапримерефункциицелочисленногосложенияиделения.🔼top"><strong>Приложение на <strong>Python</strong>. Использование модуля <code>ctypes</code> на примере функции целочисленного сложения и деления.</strong> <a href="#top">🔼</a></h2>

<p>Создание библиотеки на <strong>C</strong>:</p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-comment">// math_lib.c</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> 
{
    <span class="hljs-keyword">return</span> x + y;
}

<span class="hljs-type">int</span> <span class="hljs-title function_">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> *rem)</span> 
{
	<span class="hljs-type">int</span> rc = OK;
	
    <span class="hljs-keyword">if</span> (y != <span class="hljs-number">0</span>) 
    {
        *rem = x % y;
        rc = x / y;
    } 
    <span class="hljs-keyword">else</span> 
    {
        rc = <span class="hljs-number">0</span>
    }
    
	<span class="hljs-keyword">return</span> rc;
}
</code></pre>

<p>Использование библиотеки в <strong>Python</strong>:</p>

<pre><code class="python hljs language-python" data-highlighted="yes"><span class="hljs-keyword">import</span> ctypes

<span class="hljs-comment"># Загрузка библиотеки</span>
lib = ctypes.CDLL(<span class="hljs-string">'/libmath.so'</span>)

<span class="hljs-comment"># Указываем типы аргументов и возвращаемые типы для функции add</span>
lib.add.argtypes = (ctypes.c_int, ctypes.c_int)
lib.add.restype = ctypes.c_int

<span class="hljs-comment"># Указываем типы аргументов и возвращаемые типы для функции divide</span>
lib.divide.argtypes = (ctypes.c_int, ctypes.c_int, ctypes.POINTER(ctypes.c_int))
lib.divide.restype = ctypes.c_int

<span class="hljs-comment"># Вызов функции сложения</span>
x, y = <span class="hljs-number">10</span>, <span class="hljs-number">5</span>
result_add = lib.add(x, y)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"Sum: {}"</span>.<span class="hljs-built_in">format</span>(result_add))

<span class="hljs-comment"># Вызов функции деления</span>
rem = ctypes.c_int()
result_div = lib.divide(x, y, ctypes.byref(rem))
<span class="hljs-built_in">print</span>(<span class="hljs-string">"Div: {}, Rem: {}"</span>.<span class="hljs-built_in">format</span>(result_div, rem.value))
</code></pre>

<h2 id="Приложениенаpython.Использованиемодуляctypesнапримерефункцийобработкимассивов.🔼top"><strong>Приложение на <strong>Python</strong>. Использование модуля <code>ctypes</code> на примере функций обработки массивов.</strong> <a href="#top">🔼</a></h2>

<ol>
<li>Создание библиотеки на C</li>
</ol>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-comment">// array_lib.c</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-type">void</span> <span class="hljs-title function_">array_add</span><span class="hljs-params">(<span class="hljs-type">int</span> *arr, <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> value)</span> 
{
    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) 
    {
        arr[i] += value;
    }
}

<span class="hljs-type">int</span> <span class="hljs-title function_">array_sum</span><span class="hljs-params">(<span class="hljs-type">int</span> *arr, <span class="hljs-type">int</span> size)</span> 
{
    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;
    
    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) 
    {
        sum += arr[i];
    }
    
    <span class="hljs-keyword">return</span> sum;
}
</code></pre>

<ol>
<li>Использование библиотеки в Python</li>
</ol>

<pre><code class="python hljs language-python" data-highlighted="yes"><span class="hljs-keyword">import</span> ctypes

<span class="hljs-comment"># Загрузка библиотеки</span>
lib = ctypes.CDLL(<span class="hljs-string">'/libarray.so'</span>)

<span class="hljs-comment"># Указываем типы аргументов и возвращаемые типы для функции array_add</span>
lib.array_add.argtypes = (ctypes.POINTER(ctypes.c_int), ctypes.c_int, ctypes.c_int)
lib.array_add.restype = <span class="hljs-literal">None</span>

<span class="hljs-comment"># Указываем типы аргументов и возвращаемые типы для функции array_sum</span>
lib.array_sum.argtypes = (ctypes.POINTER(ctypes.c_int), ctypes.c_int)
lib.array_sum.restype = ctypes.c_int

<span class="hljs-comment"># Создаем и инициализируем массив в Python</span>
size = <span class="hljs-number">5</span>
arr = (ctypes.c_int * size)(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)

<span class="hljs-comment"># Вызов функции array_add, которая добавляет значение ко всем элементам массива</span>
value_to_add = <span class="hljs-number">10</span>
lib.array_add(arr, size, value_to_add)

<span class="hljs-comment"># Печать измененного массива</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"Upd array:"</span>, <span class="hljs-built_in">list</span>(arr))

<span class="hljs-comment"># Вызов функции array_sum для подсчета суммы элементов массива</span>
array_total = lib.array_sum(arr, size)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"Array sum:"</span>, array_total)
</code></pre>

<h2 id="Приложениенаpython.Обработкамассивоввмодулерасширения.🔼top"><strong>Приложение на <strong>Python</strong>. Обработка массивов в модуле расширения.</strong> <a href="#top">🔼</a></h2>

<p>Обычно функции модуля расширения имеют следующий вид:</p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">static</span> PyObject* <span class="hljs-title function_">py_func</span><span class="hljs-params">(PyObject* self, PyObject* args)</span>
{
 ...
}

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Python.h&gt;</span></span>

<span class="hljs-comment">// int add(int, int);</span>
<span class="hljs-type">static</span> PyObject *<span class="hljs-title function_">add_numbers</span><span class="hljs-params">(PyObject *self, PyObject *args)</span>
{
    <span class="hljs-type">int</span> a, b, c;
    PyObject *rc = <span class="hljs-literal">NULL</span>;

    <span class="hljs-keyword">if</span> (PyArg_ParseTuple(args, <span class="hljs-string">"ii"</span>, &amp;a, &amp;b)) 
    {
        c = add(a, b);
        rc = Py_BuildValue(<span class="hljs-string">"i"</span>, c);
    }
    
    <span class="hljs-keyword">return</span> rc;
}

<span class="hljs-comment">// int divide(int, int, int *);</span>
<span class="hljs-type">static</span> PyObject *<span class="hljs-title function_">divide_numbers</span><span class="hljs-params">(PyObject *self, PyObject *args)</span>
{
    <span class="hljs-type">int</span> a, b, quotient, remainder;
    PyObject *rc = <span class="hljs-literal">NULL</span>;

    <span class="hljs-keyword">if</span> (PyArg_ParseTuple(args, <span class="hljs-string">"ii"</span>, &amp;a, &amp;b)) 
    {
        quotient = divide(a, b, &amp;remainder);
        rc = Py_BuildValue(<span class="hljs-string">"(ii)"</span>, quotient, remainder);
    }
    
    <span class="hljs-keyword">return</span> rc;
}

<span class="hljs-comment">// Метаинформация</span>
<span class="hljs-type">static</span> PyMethodDef methods[] = {
	<span class="hljs-comment">// Имя функции на Питон, имя самой функции, набор флагов для вызова этой фукнции, строка документирования</span>
	{<span class="hljs-string">"add"</span>, add_numbers, METH_VARARGS, <span class="hljs-string">"Integer Addiction"</span>},
	{<span class="hljs-string">"divide"</span>, divide_numbers, METH_VARARGS, <span class="hljs-string">"Integer Division"</span>},
	{<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>} <span class="hljs-comment">// Сигнал о том, что таблица методов заполнена</span>
}

<span class="hljs-comment">// Описание модуля</span>
<span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> PyModuleDef module = {
	PyModuleDef_HEAD_INIT, <span class="hljs-comment">// По стандарту</span>
	<span class="hljs-string">"extension_module"</span>, <span class="hljs-comment">// Имя модуля</span>
	<span class="hljs-literal">NULL</span>,  <span class="hljs-comment">// Строка документирования</span>
	<span class="hljs-number">-1</span>, <span class="hljs-comment">// Набор флагов, которые говорят каким именно образом вызывается интерпретатор</span>
	methods  <span class="hljs-comment">// Таблица функций модуля расширения</span>
};

<span class="hljs-comment">// Функция инициализации модуля расширения</span>
PyMODINIT_FUNC <span class="hljs-title function_">PyInit_module</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
	<span class="hljs-keyword">return</span> PyModule_Create(&amp;module);
}
</code></pre>

<ul>
<li><code>PyObject</code> – это тип данных <strong>Си</strong>, представляющий любой объект <strong>Python</strong>.</li>
<li>Функция модуля расширения получает кортеж таких объектов (<code>args</code>) и возвращает новый <strong>Python</strong> объект в качестве результата.</li>
<li>Аргумент <code>self</code> не используется в простых функциях.</li>
<li>Ближе к концу модуля расширения располагаются таблица методов модуля <code>PyMethodDef</code> и структура PyModuleDef, которая описывает модуль в целом.</li>
<li>В таблице <code>PyMethodDef</code> перечисляются

<ul>
<li><strong>Си</strong> функции;</li>
<li>имена, используемые в <strong>Python</strong>;</li>
<li>флаги, используемые при вызове функции,</li>
<li>строки документации.</li>
</ul></li>
<li>Структура <code>PyModuleDef</code> используется для загрузки модуля.</li>
<li>В самом конце модуля располагается функция инициализации модуля, которая практически всегда одинакова, за исключением своего имени.</li>
</ul>

<p>Для компиляции модуля используется Python-скрипт <code>setup.py</code>. Компиляция выполняется с помощью команды:</p>

<pre><code class="c hljs language-c" data-highlighted="yes">python setup.py build_ext --inplace
</code></pre>

<div style="page-break-after: always;"></div>

<h1 id="АТДмодульразновидностимодулей.🔼top"><strong>АТД, модуль, разновидности модулей.</strong> <a href="#top">🔼</a></h1>

<p>Программу удобно рассматривать как набор независимых модулей.</p>

<ul>
<li>Модуль состоит из двух частей: интерфейса (он один) и реализации (их может быть несколько);</li>
<li>Интерфейс описывает, что делает модуль. Он определяет идентификаторы, типы и подпрограммы, которые будут доступны клиентскому коду;</li>
<li>Реализация описывает, как модуль выполняет функции, описанные в интерфейсе;</li>
<li>Часть кода, которая использует модуль, называют клиентом;</li>
<li>Клиент должен зависеть только от интерфейса, но не от деталей его реализации.</li>
</ul>

<p><strong>Интерфейс модуля в языке Си:</strong></p>

<ul>
<li>Описывается в заголовочном файле (<code>.h</code>), где объявляются функции, типы и макросы;</li>
<li>Подключается через <code>#include</code>;</li>
<li>Реализация (<code>.c</code>) определяет переменные и функции, обеспечивающие работу интерфейса.</li>
</ul>

<p><strong>Преимущества использования модулей.</strong></p>

<ul>
<li><strong>Абстракция</strong> — клиенту не нужно знать, как работает модуль, важно только, что он делает;</li>
<li><strong>Повторное использование</strong> — модуль можно применять в других программах;</li>
<li><strong>Сопровождение</strong> — можно заменить реализацию модуля, сохранив интерфейс.</li>
</ul>

<p><strong>Типы модулей.</strong></p>

<ul>
<li><strong>Набор данных</strong> — содержит переменные и константы (<code>float.h</code>, <code>limits.h</code>);</li>
<li><strong>Библиотека</strong> — содержит функции, выполняющие общие задачи;</li>
<li><strong>Абстрактный объект</strong> — скрывает структуру данных и предоставляет функции для работы с ней;</li>
<li><strong>Абстрактный тип данных (АТД)</strong> — интерфейс, скрывающий представление данных и операции с ними.</li>
</ul>

<h2 id="АО-стекцелыхчисел.🔼top"><strong>АО - стек целых чисел.</strong> <a href="#top">🔼</a></h2>

<p><strong>Пример АО (абстрактного объекта) — стек целых чисел.</strong></p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __STACK_O_H__</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> __STACK_O_H__</span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdbool.h&gt;</span></span>

<span class="hljs-type">void</span> <span class="hljs-title function_">make_empty</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;
<span class="hljs-type">bool</span> <span class="hljs-title function_">is_empty</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;
<span class="hljs-type">bool</span> <span class="hljs-title function_">is_full</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;
<span class="hljs-type">int</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>;
<span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">(<span class="hljs-type">int</span> *i)</span>;

<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// __STACK_O_H__</span></span>
</code></pre>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stddef.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stack_ao.h"</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> STACK_SIZE 10</span>

<span class="hljs-type">static</span> <span class="hljs-type">int</span> content[STACK_SIZE];
<span class="hljs-type">static</span> <span class="hljs-type">size_t</span> top;

<span class="hljs-type">void</span> <span class="hljs-title function_">make_empty</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
	top = <span class="hljs-number">0</span>;
}

<span class="hljs-type">bool</span> <span class="hljs-title function_">is_empty</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
	<span class="hljs-keyword">return</span> top == <span class="hljs-number">0</span>;
}

<span class="hljs-type">bool</span> <span class="hljs-title function_">is_full</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
	<span class="hljs-keyword">return</span> top &gt;= STACK_SIZE;
}

<span class="hljs-type">int</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>
{
	<span class="hljs-type">int</span> rc = <span class="hljs-number">0</span>;

	<span class="hljs-keyword">if</span> (is_full())
	{
		rc = <span class="hljs-number">1</span>;
	}
	<span class="hljs-keyword">else</span>
	{
		content[top++] = i;
	}

	<span class="hljs-keyword">return</span> rc;
}

<span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">(<span class="hljs-type">int</span> *i)</span>
{
	<span class="hljs-type">int</span> rc = <span class="hljs-number">0</span>;

	<span class="hljs-keyword">if</span> (is_empty())
	{
		rc = <span class="hljs-number">1</span>;
	}
	<span class="hljs-keyword">else</span>
	{
		*i = content[--top];
	}

	<span class="hljs-keyword">return</span> rc;
}
</code></pre>

<h2 id="АТД-стекцелыхчисел.🔼top"><strong>АТД - стек целых чисел.</strong> <a href="#top">🔼</a></h2>

<p><strong>Пример АТД — стек целых чисел.</strong></p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __STACK_H__</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> __STACK_H__</span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdbool.h&gt;</span></span>

<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stack_type</span> *<span class="hljs-title">stack_t</span>;</span>

<span class="hljs-type">void</span> <span class="hljs-title function_">make_empty</span><span class="hljs-params">(<span class="hljs-type">stack_t</span> s)</span>;
<span class="hljs-type">bool</span> <span class="hljs-title function_">is_empty</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">stack_t</span> s)</span>;
<span class="hljs-type">bool</span> <span class="hljs-title function_">is_full</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">stack_t</span> s)</span>;
<span class="hljs-type">int</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">stack_t</span> s, <span class="hljs-type">int</span> i)</span>;
<span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">(<span class="hljs-type">stack_t</span> s, <span class="hljs-type">int</span> *i)</span>;

<span class="hljs-type">stack_t</span> <span class="hljs-title function_">create</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;
<span class="hljs-type">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">(<span class="hljs-type">stack_t</span> s)</span>;

<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// __STACK_H__</span></span>
</code></pre>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stddef.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stack.h"</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> STACK_SIZE 10</span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stack_type</span>
{</span>
	<span class="hljs-type">int</span> content[STACK_SIZE];
	<span class="hljs-type">size_t</span> top;
};

<span class="hljs-type">stack_t</span> <span class="hljs-title function_">create</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
	<span class="hljs-type">stack_t</span> s = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> stack_type));
	<span class="hljs-type">int</span> rc = <span class="hljs-number">0</span>;

	<span class="hljs-keyword">if</span> (s == <span class="hljs-literal">NULL</span>)
	{
		rc = <span class="hljs-number">1</span>;
	}
	<span class="hljs-keyword">else</span>
	{
		make_empty(s);
	}

	<span class="hljs-keyword">return</span> rc == <span class="hljs-number">0</span> ? s : <span class="hljs-literal">NULL</span>;
}

<span class="hljs-type">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">(<span class="hljs-type">stack_t</span> s)</span>
{
	<span class="hljs-built_in">free</span>(s);
}

<span class="hljs-type">void</span> <span class="hljs-title function_">make_empty</span><span class="hljs-params">(<span class="hljs-type">stack_t</span> s)</span>
{
	assert(s);
	s-&gt;top = <span class="hljs-number">0</span>;
}

<span class="hljs-type">bool</span> <span class="hljs-title function_">is_empty</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">stack_t</span> s)</span>
{
	assert(s);
	<span class="hljs-keyword">return</span> s-&gt;top == <span class="hljs-number">0</span>;
}

<span class="hljs-type">bool</span> <span class="hljs-title function_">is_full</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">stack_t</span> s)</span>
{
	assert(s);
	<span class="hljs-keyword">return</span> s-&gt;top &gt;= STACK_SIZE;
}

<span class="hljs-type">int</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">stack_t</span> s, <span class="hljs-type">int</span> i)</span>
{
	assert(s);
	<span class="hljs-type">int</span> rc = <span class="hljs-number">0</span>;

	<span class="hljs-keyword">if</span> (is_full(s))
	{
		rc = <span class="hljs-number">1</span>;
	}
	<span class="hljs-keyword">else</span>
	{
		s-&gt;content[(s-&gt;top)++] = i;
	}

	<span class="hljs-keyword">return</span> rc;
}

<span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">(<span class="hljs-type">stack_t</span> s, <span class="hljs-type">int</span> *i)</span>
{
	assert(s);
	<span class="hljs-type">int</span> rc = <span class="hljs-number">0</span>;

	<span class="hljs-keyword">if</span> (is_empty(s))
	{
		rc = <span class="hljs-number">1</span>;
	}
	<span class="hljs-keyword">else</span>
	{
		*i = s-&gt;content[--(s-&gt;top)];
	}

	<span class="hljs-keyword">return</span> rc;
}
</code></pre>

<p><strong>Неполный тип в Си.</strong></p>

<p><strong>Стандарт Си</strong> определяет <strong>неполные типы</strong> — это типы, которые описывают объект, но <strong>не предоставляют информацию о его размере</strong>.</p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">t</span>;</span>
</code></pre>

<p><strong>Ограничения неполного типа.</strong></p>

<p><strong>Можно:</strong></p>

<ul>
<li>Объявлять указатели <code>typedef struct t *T;</code>;</li>
<li>Передавать переменные типа <code>T</code> в функции.</li>
</ul>

<p><strong>Нельзя:</strong></p>

<ul>
<li>Разыменовывать указатель <code>T</code>;</li>
<li>Обращаться к полям структуры (<code>-&gt;</code>).</li>
</ul>

<div style="page-break-after: always;"></div>

<h1 id="Спискиядраlinuxидеяосновныемоментыиспользования.🔼top"><strong>Списки ядра Linux, идея, основные моменты использования.</strong> <a href="#top">🔼</a></h1>

<p><strong>Список Беркли</strong> – это циклический двусвязный
список, в основе которого лежит следующая
структура:</p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>
{</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> *<span class="hljs-title">next</span>, *<span class="hljs-title">prev</span>;</span>
};
</code></pre>

<p>В отличие от обычных списков, где данные
содержатся в элементах списка, структура <code>list_head</code> должна быть частью самих данных.</p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">data</span>
{</span>
	<span class="hljs-type">int</span> i;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span>
	...
};
</code></pre>

<p>Следует отметить следующее:</p>

<ul>
<li>Структуру <code>struct list_head</code> можно поместить в любом месте в определении структуры.</li>
<li><code>struct list_head</code> может иметь любое имя.</li>
<li>В структуре может быть несколько полей типа <code>struct list_head</code>.</li>
</ul>

<p>+: Одно выделение памяти на узел списка.</p>

<p>-: Независимо от того в списке узел или нет
присутствуют два дополнительных
указателя.</p>

<p><strong>Использование списков ядра Linux.</strong></p>

<p><strong>Создание списка.</strong></p>

<pre><code class="c hljs language-c" data-highlighted="yes">LIST_HEAD(num_list);
</code></pre>

<p>Альтернативный способ:</p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">num_list</span>;</span>
INIT_LIST_HEAD(&amp;num_list);
</code></pre>

<p><strong>Добавление элементов.</strong></p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">data_t</span> *<span class="hljs-title">item</span>;</span>
<span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)
{
	item = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(*item));
	
	<span class="hljs-keyword">if</span> (!item)
	{
		<span class="hljs-keyword">break</span>;
	}
	<span class="hljs-keyword">else</span>
	{
		item-&gt;num = i;
		INIT_LIST_HEAD(&amp;(item-&gt;<span class="hljs-built_in">list</span>));
		list_add(&amp;(item-&gt;<span class="hljs-built_in">list</span>), &amp;num_list);
	}
}
</code></pre>

<p><strong>Обход списка.</strong></p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> *<span class="hljs-title">iter</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">data_t</span> *<span class="hljs-title">item</span>;</span>

list_for_each(iter, &amp;num_list)
{
	item = list_entry(iter, <span class="hljs-keyword">struct</span> <span class="hljs-type">data_t</span>, <span class="hljs-built_in">list</span>);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"LIST: %d\n"</span>, item-&gt;num);
}
</code></pre>

<p><strong>Альтернативный метод:</strong></p>

<pre><code class="c hljs language-c" data-highlighted="yes">list_for_each_entry(item, &amp;num_list, <span class="hljs-built_in">list</span>)
{
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"LIST: %d\n"</span>, item-&gt;num);
}
</code></pre>

<p><strong>Удаление элементов.</strong></p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> *<span class="hljs-title">safe</span>;</span>
list_for_each_safe(iter, safe, &amp;num_list)
{
	item = list_entry(iter, <span class="hljs-keyword">struct</span> <span class="hljs-type">data_t</span>, <span class="hljs-built_in">list</span>);
	list_del(iter);
	<span class="hljs-built_in">free</span>(item);
}
</code></pre>

<div style="page-break-after: always;"></div>

<h1 id="Спискиядраlinuxидеяосновныемоментыреализации.🔼top"><strong>Списки ядра Linux, идея, основные моменты реализации.</strong> <a href="#top">🔼</a></h1>

<p><strong>Список Беркли</strong> – это циклический двусвязный
список, в основе которого лежит следующая
структура:</p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>
{</span>
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> *<span class="hljs-title">next</span>, *<span class="hljs-title">prev</span>;</span>
};
</code></pre>

<p>В отличие от обычных списков, где данные
содержатся в элементах списка, структура <code>list_head</code> должна быть частью самих данных.</p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">data</span>
{</span>
	<span class="hljs-type">int</span> i;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span>
	...
};
</code></pre>

<p>Следует отметить следующее:</p>

<ul>
<li>Структуру <code>struct list_head</code> можно поместить в любом месте в определении структуры.</li>
<li><code>struct list_head</code> может иметь любое имя.</li>
<li>В структуре может быть несколько полей типа <code>struct list_head</code>.</li>
</ul>

<p>+: Одно выделение памяти на узел списка.</p>

<p>-: Независимо от того в списке узел или нет
присутствуют два дополнительных
указателя.</p>

<p><strong>Реализация списков в Linux.</strong></p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIST_HEAD_INIT(name) { &amp;(name), &amp;(name) }</span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> LIST_HEAD(name) struct list_head name = LIST_HEAD_INIT(name)</span>

<span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">INIT_LIST_HEAD</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> list_head *<span class="hljs-built_in">list</span>)</span>
{
	<span class="hljs-built_in">list</span>-&gt;next = <span class="hljs-built_in">list</span>;
	<span class="hljs-built_in">list</span>-&gt;prev = <span class="hljs-built_in">list</span>;
}
</code></pre>

<p><strong>Макрос <code>container_of</code>.</strong></p>

<p>Используется для получения указателя на структуру по адресу одного из ее полей.</p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-meta">#<span class="hljs-keyword">define</span> container_of(ptr, type, field_name) \
	((type *) ((char *) (ptr) - offsetof(type, field_name)))</span>
</code></pre>

<p><code>offsetof</code> вычисляет смещение поля <code>field_name</code> от начала структуры <code>type</code>.</p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-meta">#<span class="hljs-keyword">define</span> offsetof(TYPE, MEMBER) \
	((size_t) &amp;((TYPE *) 0)-&gt;MEMBER)</span>
</code></pre>

<p><strong>Пример работы <code>container_of</code>.</strong></p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">data_t</span>
{</span>
	<span class="hljs-type">int</span> num;
	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span>
};

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> *<span class="hljs-title">node</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">data_t</span> *<span class="hljs-title">data</span> =</span> container_of(node, <span class="hljs-keyword">struct</span> <span class="hljs-type">data_t</span>, <span class="hljs-built_in">list</span>);
</code></pre>

<p><strong><code>offsetof</code>: идея.</strong></p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">s</span>
{</span>
	<span class="hljs-type">char</span> c;
	<span class="hljs-type">int</span> i;
	<span class="hljs-type">double</span> d;
};

<span class="hljs-comment">// Получаем смещение i внутри структуры s</span>
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"offset of i is %d\n"</span>, offsetof(<span class="hljs-keyword">struct</span> s, i));
</code></pre>

<p><strong>Операции со списком.</strong></p>

<p><strong>Добавление элемента.</strong></p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> __list_add(<span class="hljs-keyword">struct</span> list_head *new,
<span class="hljs-keyword">struct</span> list_head *prev,
<span class="hljs-keyword">struct</span> list_head *next)
{
	next-&gt;prev = new;
	new-&gt;next = next;
	new-&gt;prev = prev;
	prev-&gt;next = new;
}

<span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">list_add</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> list_head *new,
<span class="hljs-keyword">struct</span> list_head *head)</span>
{
	__list_add(new, head, head-&gt;next);
}

<span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">list_add_tail</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> list_head *new,
<span class="hljs-keyword">struct</span> list_head *head)</span>
{
	__list_add(new, head-&gt;prev, head);
}
</code></pre>

<p><strong>Обход списка.</strong></p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-meta">#<span class="hljs-keyword">define</span> list_for_each(pos, head) \
	for (pos = (head)-&gt;next; pos != (head); pos = pos-&gt;next)</span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> list_for_each_entry(pos, head, member) \
	for (pos = list_entry((head)-&gt;next, typeof(*pos), member); \
		 &amp;pos-&gt;member != (head); \
		 pos = list_entry(pos-&gt;member.next, typeof(*pos), member))</span>
</code></pre>

<p><strong>Удаление элемента.</strong></p>

<pre><code class="c hljs language-c" data-highlighted="yes"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> __list_del(<span class="hljs-keyword">struct</span> list_head *prev,
<span class="hljs-keyword">struct</span> list_head *next)
{
	next-&gt;prev = prev;
	prev-&gt;next = next;
}

<span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">list_del</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> list_head *entry)</span>
{
	__list_del(entry-&gt;prev, entry-&gt;next);
	entry-&gt;next = <span class="hljs-literal">NULL</span>;
	entry-&gt;prev = <span class="hljs-literal">NULL</span>;
}
</code></pre>




</body></html>